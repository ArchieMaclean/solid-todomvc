/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-plugin-jsx-dom-expressions/dist/createRuntime.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/babel-plugin-jsx-dom-expressions/dist/createRuntime.js ***!
  \*****************************************************************************/
/*! exports provided: createRuntime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createRuntime\", function() { return createRuntime; });\nvar NOMATCH = -1,\n    NOINSERT = -2;\nvar RECONCILE_ARRAY_BATCH = 0;\nconst RECONCILE_ARRAY_BITS = 16,\n      RECONCILE_ARRAY_INC = 1 << RECONCILE_ARRAY_BITS,\n      RECONCILE_ARRAY_MASK = RECONCILE_ARRAY_INC - 1; // reconcileArray is lifted almost unaltered from SurplusJS https://github.com/adamhaile/surplus\n// reconcile the content of parent from ns to us\n// see ivi's excellent writeup of diffing arrays in a vdom library:\n// https://github.com/ivijs/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1187\n// this code isn't identical, since we're diffing real dom nodes to nodes-or-strings,\n// but the core methodology of trimming ends and reversals, matching nodes, then using\n// the longest increasing subsequence to minimize DOM ops is inspired by ivi.\n\nfunction reconcileArrays(parent, ns, us, multiple) {\n  var ulen = us.length,\n      // n = nodes, u = updates\n  // ranges defined by min and max indices\n  nmin = 0,\n      nmax = ns.length - 1,\n      umin = 0,\n      umax = ulen - 1,\n      // start nodes of ranges\n  n = ns[nmin],\n      u = us[umin],\n      // end nodes of ranges\n  nx = ns[nmax],\n      ux = us[umax],\n      // node, if any, just after ux, used for doing .insertBefore() to put nodes at end\n  ul = nx.nextSibling,\n      i,\n      j,\n      k,\n      loop = true; // scan over common prefixes, suffixes, and simple reversals\n\n  fixes: while (loop) {\n    loop = false; // common prefix, u === n\n\n    while (equable(u, n, umin, us)) {\n      umin++;\n      nmin++;\n      if (umin > umax || nmin > nmax) break fixes;\n      u = us[umin];\n      n = ns[nmin];\n    } // common suffix, ux === nx\n\n\n    while (equable(ux, nx, umax, us)) {\n      ul = nx;\n      umax--;\n      nmax--;\n      if (umin > umax || nmin > nmax) break fixes;\n      ux = us[umax];\n      nx = ns[nmax];\n    } // reversal u === nx, have to swap node forward\n\n\n    while (equable(u, nx, umin, us)) {\n      loop = true;\n      parent.insertBefore(nx, n);\n      umin++;\n      nmax--;\n      if (umin > umax || nmin > nmax) break fixes;\n      u = us[umin];\n      nx = ns[nmax];\n    } // reversal ux === n, have to swap node back\n\n\n    while (equable(ux, n, umax, us)) {\n      loop = true;\n      if (ul === null) parent.appendChild(n);else parent.insertBefore(n, ul);\n      ul = n;\n      umax--;\n      nmin++;\n      if (umin > umax || nmin > nmax) break fixes;\n      ux = us[umax];\n      n = ns[nmin];\n    }\n  } // if that covered all updates, just need to remove any remaining nodes and we're done\n\n\n  if (umin > umax) {\n    // remove any remaining nodes\n    while (nmin <= nmax) {\n      parent.removeChild(ns[nmax]);\n      nmax--;\n    }\n\n    return;\n  } // if that covered all current nodes, just need to insert any remaining updates and we're done\n\n\n  if (nmin > nmax) {\n    // insert any remaining nodes\n    while (umin <= umax) {\n      insertOrAppend(parent, us[umin], ul, umin, us);\n      umin++;\n    }\n\n    return;\n  } // simple cases don't apply, have to actually match up nodes and figure out minimum DOM ops\n  // loop through nodes and mark them with a special property indicating their order\n  // we'll then go through the updates and look for those properties\n  // in case any of the updates have order properties left over from earlier runs, we \n  // use the low bits of the order prop to record a batch identifier.\n  // I'd much rather use a Map than a special property, but Maps of objects are really\n  // slow currently, like only 100k get/set ops / second\n  // for Text nodes, all that matters is their order, as they're easily, interchangeable\n  // so we record their positions in ntext[]\n\n\n  var ntext = []; // update global batch identifer\n\n  RECONCILE_ARRAY_BATCH = (RECONCILE_ARRAY_BATCH + 1) % RECONCILE_ARRAY_INC;\n\n  for (i = nmin, j = (nmin << RECONCILE_ARRAY_BITS) + RECONCILE_ARRAY_BATCH; i <= nmax; i++, j += RECONCILE_ARRAY_INC) {\n    n = ns[i]; // add or update special order property\n\n    if (n.__sp_order === undefined) {\n      Object.defineProperty(n, '__sp_order', {\n        value: j,\n        writable: true\n      });\n    } else {\n      n.__sp_order = j;\n    }\n\n    if (n instanceof Text) {\n      ntext.push(i);\n    }\n  } // now loop through us, looking for the order property, otherwise recording NOMATCH\n\n\n  var src = new Array(umax - umin + 1),\n      utext = [],\n      preserved = 0;\n\n  for (i = umin; i <= umax; i++) {\n    u = us[i];\n\n    if (typeof u === 'string') {\n      utext.push(i);\n      src[i - umin] = NOMATCH;\n    } else if ((j = u.__sp_order) !== undefined && (j & RECONCILE_ARRAY_MASK) === RECONCILE_ARRAY_BATCH) {\n      j >>= RECONCILE_ARRAY_BITS;\n      src[i - umin] = j;\n      ns[j] = null;\n      preserved++;\n    } else {\n      src[i - umin] = NOMATCH;\n    }\n  }\n\n  if (preserved === 0 && nmin === 0 && nmax === ns.length - 1) {\n    if (multiple) {\n      while (umin <= umax) {\n        insertOrAppend(parent, us[umin], ns[0], umin, us);\n        umin++;\n      }\n\n      for (i = 0; i < ns; i++) {\n        parent.removeChild(ns[i]);\n      }\n\n      return;\n    } // no nodes preserved, use fast clear and append\n\n\n    parent.textContent = '';\n\n    while (umin <= umax) {\n      insertOrAppend(parent, us[umin], null, umin, us);\n      umin++;\n    }\n\n    return;\n  } // find longest common sequence between ns and us, represented as the indices\n  // of the longest increasing subsequence in src\n\n\n  var lcs = longestPositiveIncreasingSubsequence(src); // we know we can preserve their order, so march them as NOINSERT\n\n  for (i = 0; i < lcs.length; i++) {\n    src[lcs[i]] = NOINSERT;\n  }\n  /*\r\n          0   1   2   3   4   5   6   7\r\n  ns    = [ n,  n,  t,  n,  n,  n,  t,  n ]\r\n              |          /   /       /\r\n              |        /   /       /\r\n              +------/---/-------/----+\r\n                    /   /       /      |\r\n  us    = [ n,  s,  n,  n,  s,  n,  s,  n ]\r\n  src   = [-1, -1,  4,  5, -1,  7, -1,  1 ]\r\n  lis   = [         2,  3,      5]\r\n                  j\r\n  utext = [     1,          4,      6 ]\r\n              i\r\n  ntext = [         2,              6 ]\r\n                  k\r\n  */\n  // replace strings in us with Text nodes, reusing Text nodes from ns when we can do so without moving them\n\n\n  var utexti = 0,\n      lcsj = 0,\n      ntextk = 0;\n\n  for (i = 0, j = 0, k = 0; i < utext.length; i++) {\n    utexti = utext[i]; // need to answer qeustion \"if utext[i] falls between two lcs nodes, is there an ntext between them which we can reuse?\"\n    // first, find j such that lcs[j] is the first lcs node *after* utext[i]\n\n    while (j < lcs.length && (lcsj = lcs[j]) < utexti - umin) j++; // now, find k such that ntext[k] is the first ntext *after* lcs[j-1] (or after start, if j === 0)\n\n\n    while (k < ntext.length && (ntextk = ntext[k], j !== 0) && ntextk < src[lcs[j - 1]]) k++; // if ntext[k] < lcs[j], then we know ntext[k] falls between lcs[j-1] (or start) and lcs[j] (or end)\n    // that means we can re-use it without moving it\n\n\n    if (k < ntext.length && (j === lcs.length || ntextk < src[lcsj])) {\n      n = ns[ntextk];\n      u = us[utexti];\n      if (n.data !== u) n.data = u;\n      ns[ntextk] = null;\n      us[utexti] = n;\n      src[utexti] = NOINSERT;\n      k++;\n    } else {\n      // if we didn't find one to re-use, make a new Text node\n      us[utexti] = document.createTextNode(us[utexti]);\n    }\n  } // remove stale nodes in ns\n\n\n  while (nmin <= nmax) {\n    n = ns[nmin];\n\n    if (n !== null) {\n      parent.removeChild(n);\n    }\n\n    nmin++;\n  } // insert new nodes\n\n\n  while (umin <= umax) {\n    ux = us[umax];\n\n    if (src[umax - umin] !== NOINSERT) {\n      if (ul === null) parent.appendChild(ux);else parent.insertBefore(ux, ul);\n    }\n\n    ul = ux;\n    umax--;\n  }\n} // two nodes are \"equable\" if they are identical (===) or if we can make them the same, i.e. they're \n// Text nodes, which we can reuse with the new text\n\n\nfunction equable(u, n, i, us) {\n  if (u === n) {\n    return true;\n  } else if (typeof u === 'string' && n instanceof Text) {\n    if (n.data !== u) n.data = u;\n    us[i] = n;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction insertOrAppend(parent, node, marker, i, us) {\n  if (typeof node === 'string') {\n    node = us[i] = document.createTextNode(node);\n  }\n\n  if (marker === null) parent.appendChild(node);else parent.insertBefore(node, marker);\n} // return an array of the indices of ns that comprise the longest increasing subsequence within ns\n\n\nfunction longestPositiveIncreasingSubsequence(ns) {\n  var seq = [],\n      is = [],\n      l = -1,\n      pre = new Array(ns.length);\n\n  for (var i = 0, len = ns.length; i < len; i++) {\n    var n = ns[i];\n    if (n < 0) continue;\n    var j = findGreatestIndexLEQ(seq, n);\n    if (j !== -1) pre[i] = is[j];\n\n    if (j === l) {\n      l++;\n      seq[l] = n;\n      is[l] = i;\n    } else if (n < seq[j + 1]) {\n      seq[j + 1] = n;\n      is[j + 1] = i;\n    }\n  }\n\n  for (i = is[l]; l >= 0; i = pre[i], l--) {\n    seq[l] = i;\n  }\n\n  return seq;\n}\n\nfunction findGreatestIndexLEQ(seq, n) {\n  // invariant: lo is guaranteed to be index of a value <= n, hi to be >\n  // therefore, they actually start out of range: (-1, last + 1)\n  var lo = -1,\n      hi = seq.length; // fast path for simple increasing sequences\n\n  if (hi > 0 && seq[hi - 1] <= n) return hi - 1;\n\n  while (hi - lo > 1) {\n    var mid = Math.floor((lo + hi) / 2);\n\n    if (seq[mid] > n) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n\n  return lo;\n}\n\nconst Types = {\n  ATTRIBUTE: 'attribute',\n  PROPERTY: 'property'\n};\nvar Attributes = {\n  href: {\n    type: Types.ATTRIBUTE\n  },\n  style: {\n    type: Types.PROPERTY,\n    alias: 'style.cssText'\n  },\n  for: {\n    type: Types.PROPERTY,\n    alias: 'htmlFor'\n  },\n  class: {\n    type: Types.PROPERTY,\n    alias: 'className'\n  },\n  // React compat\n  spellCheck: {\n    type: Types.PROPERTY,\n    alias: 'spellcheck'\n  },\n  allowFullScreen: {\n    type: Types.PROPERTY,\n    alias: 'allowFullscreen'\n  },\n  autoCapitalize: {\n    type: Types.PROPERTY,\n    alias: 'autocapitalize'\n  },\n  autoFocus: {\n    type: Types.PROPERTY,\n    alias: 'autofocus'\n  },\n  autoPlay: {\n    type: Types.PROPERTY,\n    alias: 'autoplay'\n  }\n};\n\nfunction normalizeIncomingArray(normalized, array) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    var item = array[i];\n\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ;else if (Array.isArray(item)) {\n      normalizeIncomingArray(normalized, item);\n    } else if (typeof item === 'string') {\n      normalized.push(item);\n    } else {\n      normalized.push(item.toString());\n    }\n  }\n\n  return normalized;\n}\n\nfunction appendNodes(parent, array) {\n  for (let i = 0, len = array.length; i < len; i++) parent.appendChild(array[i]);\n}\n\nfunction model(el) {\n  return el && (el.model || model(el.parentNode));\n}\n\nfunction createRuntime(options) {\n  const {\n    wrap\n  } = options;\n\n  function singleExpression(parent, value, current) {\n    if (value === current) return current;\n    const t = typeof value;\n\n    if (t === 'string') {\n      if (current !== \"\" && typeof current === 'string') {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    } else if ('number' === t) {\n      value = value.toString();\n\n      if (current !== \"\" && typeof current === 'string') {\n        current = parent.firstChild.data = value;\n      } else current = parent.textContent = value;\n    } else if (value == null || t === 'boolean') {\n      current = parent.textContent = '';\n    } else if (t === 'function') {\n      wrap(function () {\n        current = singleExpression(parent, value(), current);\n      });\n    } else if (value instanceof Node) {\n      if (Array.isArray(current)) {\n        if (current.length === 0) {\n          parent.appendChild(value);\n        } else if (current.length === 1) {\n          parent.replaceChild(value, current[0]);\n        } else {\n          parent.textContent = '';\n          parent.appendChild(value);\n        }\n      } else if (current == null) {\n        parent.appendChild(value);\n      } else {\n        parent.replaceChild(value, parent.firstChild);\n      }\n\n      current = value;\n    } else if (Array.isArray(value)) {\n      let array = normalizeIncomingArray([], value);\n\n      if (array.length === 0) {\n        parent.textContent = '';\n      } else {\n        if (Array.isArray(current)) {\n          if (current.length === 0) {\n            appendNodes(parent, array);\n          } else {\n            reconcileArrays(parent, current, array);\n          }\n        } else if (current == null) {\n          appendNodes(parent, array);\n        } else {\n          reconcileArrays(parent, [parent.firstChild], array);\n        }\n      }\n\n      current = array;\n    } else {\n      throw new Error(\"content must be Node, stringable, or array of same\");\n    }\n\n    return current;\n  }\n\n  function multipleExpressions(parent, value, nodes) {\n    let marker = null;\n    const t = typeof value;\n    parent = nodes[0] && nodes[0].parentNode ? nodes[0].parentNode : parent;\n\n    if (t === 'string' || t === 'number') {\n      if (nodes[0].nodeType === 3) {\n        nodes[0].data = value.toString();\n        marker = nodes[0];\n      } else {\n        value = document.createTextNode(value.toString());\n\n        if (nodes[0]) {\n          parent.replaceChild(value, nodes[0]);\n        } else parent.appendChild(value);\n\n        nodes[0] = marker = value;\n      }\n    } else if (t === 'function') {\n      wrap(function () {\n        nodes = multipleExpressions(parent, value(), nodes);\n      });\n      marker = nodes[nodes.length - 1];\n    } else if (value instanceof Node) {\n      if (nodes[0]) {\n        if (nodes[0] !== value) parent.replaceChild(value, nodes[0]);\n      } else parent.appendChild(value);\n\n      nodes[0] = marker = value;\n    } else if (Array.isArray(value)) {\n      const array = normalizeIncomingArray([], value);\n\n      if (array.length) {\n        if (!nodes.length) {\n          for (let i = 0, len = array.length; i < len; i++) {\n            const child = array[i];\n            parent.appendChild(child);\n            nodes[i] = child;\n          }\n\n          marker = nodes[array.length - 1];\n        } else {\n          reconcileArrays(parent, nodes, array, true);\n          nodes = array;\n          marker = nodes[nodes.length - 1];\n        }\n      }\n    } // handle nulls\n\n\n    if (marker == null) {\n      if (nodes[0] === parent.firstChild && nodes.length > 1 && nodes[nodes.length - 1] === parent.lastChild) {\n        parent.textContent = '';\n        value = document.createTextNode('');\n        parent.appendChild(value);\n        marker = nodes[0] = value;\n      } else if (nodes[0].nodeType === 3) {\n        nodes[0].data = '';\n        marker = nodes[0];\n      } else {\n        value = document.createTextNode('');\n        if (nodes[0]) parent.replaceChild(value, nodes[0]);else parent.appendChild(value);\n        marker = nodes[0] = value;\n      }\n    } // trim extras\n\n\n    let node;\n\n    while (marker !== (node = nodes[nodes.length - 1])) {\n      parent.removeChild(node);\n      nodes.length = nodes.length - 1;\n    }\n\n    return nodes;\n  }\n\n  return Object.assign({\n    insert(parent, accessor) {\n      if (typeof accessor !== 'function') return singleExpression(parent, accessor);\n      wrap(current => singleExpression(parent, accessor(), current));\n    },\n\n    insertM(parent, accessor, placeholder) {\n      if (typeof accessor !== 'function') return multipleExpressions(parent, accessor, [placeholder]);\n      wrap((current = [placeholder]) => multipleExpressions(parent, accessor(), current));\n    },\n\n    addEventListener(node, eventName, handler) {\n      node.addEventListener(eventName, e => {\n        if (handler.length < 2) return handler(e);\n        handler(e, model(e.target));\n      });\n    },\n\n    spread(node, accessor) {\n      wrap(function () {\n        const props = accessor();\n        let info;\n\n        for (const prop in props) {\n          const value = props[prop];\n\n          if (prop === 'style') {\n            Object.assign(node.style, value);\n          } else if (prop === 'classList') {\n            for (const className in value) node.classList.toggle(className, value[className]);\n          } else if (info = Attributes[prop]) {\n            if (info.type === 'attribute') {\n              node.setAttribute(prop, value);\n            } else node[info.alias] = value;\n          } else node[prop] = value;\n        }\n      });\n    }\n\n  }, options);\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/babel-plugin-jsx-dom-expressions/dist/createRuntime.js?");

/***/ }),

/***/ "./node_modules/s-js/dist/es/S.js":
/*!****************************************!*\
  !*** ./node_modules/s-js/dist/es/S.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Public interface\nvar S = function S(fn, value) {\n  var node = new ComputationNode(fn, value);\n  return function computation() {\n    return node.current();\n  };\n}; // compatibility with commonjs systems that expect default export to be at require('s.js').default rather than just require('s-js')\n\n\nObject.defineProperty(S, 'default', {\n  value: S\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (S);\n\nS.root = function root(fn) {\n  var owner = Owner,\n      root = fn.length === 0 ? UNOWNED : new ComputationNode(null, null),\n      result = undefined,\n      disposer = fn.length === 0 ? null : function _dispose() {\n    if (RunningClock !== null) {\n      RootClock.disposes.add(root);\n    } else {\n      dispose(root);\n    }\n  };\n  Owner = root;\n\n  if (RunningClock === null) {\n    result = topLevelRoot(fn, disposer, owner);\n  } else {\n    result = disposer === null ? fn() : fn(disposer);\n    Owner = owner;\n  }\n\n  return result;\n};\n\nfunction topLevelRoot(fn, disposer, owner) {\n  try {\n    return disposer === null ? fn() : fn(disposer);\n  } finally {\n    Owner = owner;\n  }\n}\n\nS.on = function on(ev, fn, seed, onchanges) {\n  if (Array.isArray(ev)) ev = callAll(ev);\n  onchanges = !!onchanges;\n  return S(on, seed);\n\n  function on(value) {\n    var running = RunningNode;\n    ev();\n    if (onchanges) onchanges = false;else {\n      RunningNode = null;\n      value = fn(value);\n      RunningNode = running;\n    }\n    return value;\n  }\n};\n\nfunction callAll(ss) {\n  return function all() {\n    for (var i = 0; i < ss.length; i++) ss[i]();\n  };\n}\n\nS.effect = function effect(fn, value) {\n  new ComputationNode(fn, value);\n};\n\nS.data = function data(value) {\n  var node = new DataNode(value);\n  return function data(value) {\n    if (arguments.length === 0) {\n      return node.current();\n    } else {\n      return node.next(value);\n    }\n  };\n};\n\nS.value = function value(current, eq) {\n  var data = S.data(current),\n      age = -1;\n  return function value(update) {\n    if (arguments.length === 0) {\n      return data();\n    } else {\n      var same = eq ? eq(current, update) : current === update;\n\n      if (!same) {\n        var time = RootClock.time;\n        if (age === time) throw new Error(\"conflicting values: \" + update + \" is not the same as \" + current);\n        age = time;\n        current = update;\n        data(update);\n      }\n\n      return update;\n    }\n  };\n};\n\nS.freeze = function freeze(fn) {\n  var result = undefined;\n\n  if (RunningClock !== null) {\n    result = fn();\n  } else {\n    RunningClock = RootClock;\n    RunningClock.changes.reset();\n\n    try {\n      result = fn();\n      event();\n    } finally {\n      RunningClock = null;\n    }\n  }\n\n  return result;\n};\n\nS.sample = function sample(fn) {\n  var result,\n      running = RunningNode;\n\n  if (running !== null) {\n    RunningNode = null;\n    result = fn();\n    RunningNode = running;\n  } else {\n    result = fn();\n  }\n\n  return result;\n};\n\nS.cleanup = function cleanup(fn) {\n  if (Owner !== null) {\n    if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  } else {\n    console.warn(\"cleanups created without a root or parent will never be run\");\n  }\n}; // experimental : exposing node constructors and some state\n\n\nS.makeDataNode = function makeDataNode(value) {\n  return new DataNode(value);\n};\n\nS.makeComputationNode = function makeComputationNode(fn, seed) {\n  return new ComputationNode(fn, seed);\n};\n\nS.isFrozen = function isFrozen() {\n  return RunningClock !== null;\n};\n\nS.isListening = function isListening() {\n  return RunningNode !== null;\n}; // Internal implementation\n/// Graph classes and operations\n\n\nvar Clock =\n/** @class */\nfunction () {\n  function Clock() {\n    this.time = 0;\n    this.changes = new Queue(); // batched changes to data nodes\n\n    this.updates = new Queue(); // computations to update\n\n    this.disposes = new Queue(); // disposals to run after current batch of updates finishes\n  }\n\n  return Clock;\n}();\n\nvar RootClockProxy = {\n  time: function () {\n    return RootClock.time;\n  }\n};\n\nvar DataNode =\n/** @class */\nfunction () {\n  function DataNode(value) {\n    this.value = value;\n    this.pending = NOTPENDING;\n    this.log = null;\n  }\n\n  DataNode.prototype.current = function () {\n    if (RunningNode !== null) {\n      logDataRead(this, RunningNode);\n    }\n\n    return this.value;\n  };\n\n  DataNode.prototype.next = function (value) {\n    if (RunningClock !== null) {\n      if (this.pending !== NOTPENDING) {\n        // value has already been set once, check for conflicts\n        if (value !== this.pending) {\n          throw new Error(\"conflicting changes: \" + value + \" !== \" + this.pending);\n        }\n      } else {\n        // add to list of changes\n        this.pending = value;\n        RootClock.changes.add(this);\n      }\n    } else {\n      // not batching, respond to change now\n      if (this.log !== null) {\n        this.pending = value;\n        RootClock.changes.add(this);\n        event();\n      } else {\n        this.value = value;\n      }\n    }\n\n    return value;\n  };\n\n  DataNode.prototype.clock = function () {\n    return RootClockProxy;\n  };\n\n  return DataNode;\n}();\n\nvar ComputationNode =\n/** @class */\nfunction () {\n  function ComputationNode(fn, value) {\n    this.state = CURRENT;\n    this.source1 = null;\n    this.source1slot = 0;\n    this.sources = null;\n    this.sourceslots = null;\n    this.log = null;\n    this.owned = null;\n    this.cleanups = null;\n    this.fn = fn;\n    this.value = value;\n    this.age = RootClock.time;\n    if (fn === null) return;\n    var owner = Owner,\n        running = RunningNode;\n    if (owner === null) console.warn(\"computations created without a root or parent will never be disposed\");\n    Owner = RunningNode = this;\n\n    if (RunningClock === null) {\n      toplevelComputation(this);\n    } else {\n      this.value = this.fn(this.value);\n    }\n\n    if (owner && owner !== UNOWNED) {\n      if (owner.owned === null) owner.owned = [this];else owner.owned.push(this);\n    }\n\n    Owner = owner;\n    RunningNode = running;\n  }\n\n  ComputationNode.prototype.current = function () {\n    if (RunningNode !== null) {\n      if (this.age === RootClock.time) {\n        if (this.state === RUNNING) throw new Error(\"circular dependency\");else updateNode(this); // checks for state === STALE internally, so don't need to check here\n      }\n\n      logComputationRead(this, RunningNode);\n    }\n\n    return this.value;\n  };\n\n  ComputationNode.prototype.clock = function () {\n    return RootClockProxy;\n  };\n\n  return ComputationNode;\n}();\n\nvar Log =\n/** @class */\nfunction () {\n  function Log() {\n    this.node1 = null;\n    this.node1slot = 0;\n    this.nodes = null;\n    this.nodeslots = null;\n  }\n\n  return Log;\n}();\n\nvar Queue =\n/** @class */\nfunction () {\n  function Queue() {\n    this.items = [];\n    this.count = 0;\n  }\n\n  Queue.prototype.reset = function () {\n    this.count = 0;\n  };\n\n  Queue.prototype.add = function (item) {\n    this.items[this.count++] = item;\n  };\n\n  Queue.prototype.run = function (fn) {\n    var items = this.items;\n\n    for (var i = 0; i < this.count; i++) {\n      fn(items[i]);\n      items[i] = null;\n    }\n\n    this.count = 0;\n  };\n\n  return Queue;\n}(); // Constants\n\n\nvar NOTPENDING = {},\n    CURRENT = 0,\n    STALE = 1,\n    RUNNING = 2; // \"Globals\" used to keep track of current system state\n\nvar RootClock = new Clock(),\n    RunningClock = null,\n    // currently running clock \nRunningNode = null,\n    // currently running computation\nOwner = null,\n    // owner for new computations\nUNOWNED = new ComputationNode(null, null); // Functions\n\nfunction logRead(from, to) {\n  var fromslot,\n      toslot = to.source1 === null ? -1 : to.sources === null ? 0 : to.sources.length;\n\n  if (from.node1 === null) {\n    from.node1 = to;\n    from.node1slot = toslot;\n    fromslot = -1;\n  } else if (from.nodes === null) {\n    from.nodes = [to];\n    from.nodeslots = [toslot];\n    fromslot = 0;\n  } else {\n    fromslot = from.nodes.length;\n    from.nodes.push(to);\n    from.nodeslots.push(toslot);\n  }\n\n  if (to.source1 === null) {\n    to.source1 = from;\n    to.source1slot = fromslot;\n  } else if (to.sources === null) {\n    to.sources = [from];\n    to.sourceslots = [fromslot];\n  } else {\n    to.sources.push(from);\n    to.sourceslots.push(fromslot);\n  }\n}\n\nfunction logDataRead(data, to) {\n  if (data.log === null) data.log = new Log();\n  logRead(data.log, to);\n}\n\nfunction logComputationRead(node, to) {\n  if (node.log === null) node.log = new Log();\n  logRead(node.log, to);\n}\n\nfunction event() {\n  // b/c we might be under a top level S.root(), have to preserve current root\n  var owner = Owner;\n  RootClock.updates.reset();\n  RootClock.time++;\n\n  try {\n    run(RootClock);\n  } finally {\n    RunningClock = RunningNode = null;\n    Owner = owner;\n  }\n}\n\nfunction toplevelComputation(node) {\n  RunningClock = RootClock;\n  RootClock.changes.reset();\n  RootClock.updates.reset();\n\n  try {\n    node.value = node.fn(node.value);\n\n    if (RootClock.changes.count > 0 || RootClock.updates.count > 0) {\n      RootClock.time++;\n      run(RootClock);\n    }\n  } finally {\n    RunningClock = Owner = RunningNode = null;\n  }\n}\n\nfunction run(clock) {\n  var running = RunningClock,\n      count = 0;\n  RunningClock = clock;\n  clock.disposes.reset(); // for each batch ...\n\n  while (clock.changes.count !== 0 || clock.updates.count !== 0 || clock.disposes.count !== 0) {\n    if (count > 0) // don't tick on first run, or else we expire already scheduled updates\n      clock.time++;\n    clock.changes.run(applyDataChange);\n    clock.updates.run(updateNode);\n    clock.disposes.run(dispose); // if there are still changes after excessive batches, assume runaway            \n\n    if (count++ > 1e5) {\n      throw new Error(\"Runaway clock detected\");\n    }\n  }\n\n  RunningClock = running;\n}\n\nfunction applyDataChange(data) {\n  data.value = data.pending;\n  data.pending = NOTPENDING;\n  if (data.log) markComputationsStale(data.log);\n}\n\nfunction markComputationsStale(log) {\n  var node1 = log.node1,\n      nodes = log.nodes; // mark all downstream nodes stale which haven't been already\n\n  if (node1 !== null) markNodeStale(node1);\n\n  if (nodes !== null) {\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      markNodeStale(nodes[i]);\n    }\n  }\n}\n\nfunction markNodeStale(node) {\n  var time = RootClock.time;\n\n  if (node.age < time) {\n    node.age = time;\n    node.state = STALE;\n    RootClock.updates.add(node);\n    if (node.owned !== null) markOwnedNodesForDisposal(node.owned);\n    if (node.log !== null) markComputationsStale(node.log);\n  }\n}\n\nfunction markOwnedNodesForDisposal(owned) {\n  for (var i = 0; i < owned.length; i++) {\n    var child = owned[i];\n    child.age = RootClock.time;\n    child.state = CURRENT;\n    if (child.owned !== null) markOwnedNodesForDisposal(child.owned);\n  }\n}\n\nfunction updateNode(node) {\n  if (node.state === STALE) {\n    var owner = Owner,\n        running = RunningNode;\n    Owner = RunningNode = node;\n    node.state = RUNNING;\n    cleanup(node, false);\n    node.value = node.fn(node.value);\n    node.state = CURRENT;\n    Owner = owner;\n    RunningNode = running;\n  }\n}\n\nfunction cleanup(node, final) {\n  var source1 = node.source1,\n      sources = node.sources,\n      sourceslots = node.sourceslots,\n      cleanups = node.cleanups,\n      owned = node.owned,\n      i,\n      len;\n\n  if (cleanups !== null) {\n    for (i = 0; i < cleanups.length; i++) {\n      cleanups[i](final);\n    }\n\n    node.cleanups = null;\n  }\n\n  if (owned !== null) {\n    for (i = 0; i < owned.length; i++) {\n      dispose(owned[i]);\n    }\n\n    node.owned = null;\n  }\n\n  if (source1 !== null) {\n    cleanupSource(source1, node.source1slot);\n    node.source1 = null;\n  }\n\n  if (sources !== null) {\n    for (i = 0, len = sources.length; i < len; i++) {\n      cleanupSource(sources.pop(), sourceslots.pop());\n    }\n  }\n}\n\nfunction cleanupSource(source, slot) {\n  var nodes = source.nodes,\n      nodeslots = source.nodeslots,\n      last,\n      lastslot;\n\n  if (slot === -1) {\n    source.node1 = null;\n  } else {\n    last = nodes.pop();\n    lastslot = nodeslots.pop();\n\n    if (slot !== nodes.length) {\n      nodes[slot] = last;\n      nodeslots[slot] = lastslot;\n\n      if (lastslot === -1) {\n        last.source1slot = slot;\n      } else {\n        last.sourceslots[lastslot] = slot;\n      }\n    }\n  }\n}\n\nfunction dispose(node) {\n  node.fn = null;\n  node.log = null;\n  cleanup(node, true);\n}\n\n//# sourceURL=webpack:///./node_modules/s-js/dist/es/S.js?");

/***/ }),

/***/ "./node_modules/solid-js/dist/dom.js":
/*!*******************************************!*\
  !*** ./node_modules/solid-js/dist/dom.js ***!
  \*******************************************/
/*! exports provided: r, selectWhen, selectEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"r\", function() { return r; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectWhen\", function() { return selectWhen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selectEach\", function() { return selectEach; });\n/* harmony import */ var babel_plugin_jsx_dom_expressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! babel-plugin-jsx-dom-expressions */ \"./node_modules/babel-plugin-jsx-dom-expressions/dist/createRuntime.js\");\n/* harmony import */ var s_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! s-js */ \"./node_modules/s-js/dist/es/S.js\");\n\n\n\nfunction shallowDiff(a, b) {\n  let sa = new Set(a),\n      sb = new Set(b);\n  return [a.filter(i => !sb.has(i)), b.filter(i => !sa.has(i))];\n}\n\nconst r = Object(babel_plugin_jsx_dom_expressions__WEBPACK_IMPORTED_MODULE_0__[\"createRuntime\"])({\n  wrap: s_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].makeComputationNode\n});\n\nfunction selectWhen(signal, handler) {\n  return list => {\n    s_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(signal, element => {\n      const model = signal();\n      if (element) handler(element, false);\n      if (element = model && list().find(el => el.model === model)) handler(element, true);\n      return element;\n    });\n    return list;\n  };\n}\n\nfunction selectEach(signal, handler) {\n  return list => {\n    s_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].on(signal, elements => {\n      const models = signal(),\n            newElements = list().filter(el => models.indexOf(el.model) > -1),\n            [additions, removals] = shallowDiff(newElements, elements);\n      additions.forEach(el => handler(el, true));\n      removals.forEach(el => handler(el, false));\n      return newElements;\n    });\n    return list;\n  };\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/solid-js/dist/dom.js?");

/***/ }),

/***/ "./node_modules/solid-js/dist/solid.js":
/*!*********************************************!*\
  !*** ./node_modules/solid-js/dist/solid.js ***!
  \*********************************************/
/*! exports provided: root, State, ImmutableState, unwrap, from, pipe, map, compose, when, each, observable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"root\", function() { return root; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"State\", function() { return State; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ImmutableState\", function() { return ImmutableState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrap\", function() { return unwrap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"from\", function() { return from; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pipe\", function() { return pipe; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"compose\", function() { return compose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"when\", function() { return when; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"observable\", function() { return observable; });\n/* harmony import */ var s_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! s-js */ \"./node_modules/s-js/dist/es/S.js\");\n\n\nfunction comparer(v, k, b, isArray, path, r) {\n  let ref, ref1;\n  const newPath = path.concat([k]);\n\n  if (isArray && !((v != null ? v.id : void 0) && (v != null ? v.id : void 0) === ((ref = b[k]) != null ? ref.id : void 0) || (v != null ? v._id : void 0) && (v != null ? v._id : void 0) === ((ref1 = b[k]) != null ? ref1._id : void 0)) || !(v != null && (b != null ? b[k] : void 0) != null && v instanceof Object)) {\n    return r.push(newPath.concat([v]));\n  }\n\n  return r.push.apply(r, diff(v, b[k], newPath));\n}\n\nfunction resolveAsync(value, fn) {\n  if (!isObject(value)) return fn(value);\n\n  if ('subscribe' in value) {\n    const dispose = value.subscribe(fn);\n    s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cleanup(function disposer() {\n      dispose.unsubscribe();\n    });\n    return;\n  }\n\n  if ('then' in value) {\n    value.then(fn);\n    return;\n  }\n\n  fn(value);\n}\n\nfunction isObject(obj) {\n  let ref;\n  return obj !== null && ((ref = typeof obj) === 'object' || ref === 'function');\n}\n\nfunction diff(a, b, path = []) {\n  let i, k, l, len, v;\n  const r = [];\n\n  if (!isObject(a) || b == null) {\n    if (a !== b) {\n      r.push(path.concat([a]));\n    }\n  } else if (Array.isArray(a)) {\n    for (k = i = 0, len = a.length; i < len; k = ++i) {\n      v = a[k];\n      if ((b != null ? b[k] : void 0) !== v) comparer(v, k, b, true, path, r);\n    }\n\n    if ((b != null ? b.length : void 0) > a.length) {\n      l = a.length;\n\n      while (l < b.length) {\n        r.push(path.concat([l, void 0]));\n        l++;\n      }\n    }\n  } else {\n    for (k in a) {\n      v = a[k];\n      if ((b != null ? b[k] : void 0) !== v) comparer(v, k, b, false, path, r);\n    }\n\n    for (k in b) {\n      v = b[k];\n      if (!(k in a)) r.push(path.concat([k, void 0]));\n    }\n  }\n\n  return r;\n}\n\nfunction unwrap(item, depth) {\n  let keys, result, unwrapped, v;\n  if (result = item != null ? item._state : void 0) return result;\n  if (!depth || !isObject(item) || typeof item === 'function' || item instanceof Element) return item;\n  keys = Object.keys(item);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    v = item[keys[i]];\n    if ((unwrapped = unwrap(v, depth - 1)) !== v) item[keys[i]] = unwrapped;\n  }\n\n  return item;\n}\n\nfunction clone(v) {\n  if (!isObject(v)) return v;\n  if (Array.isArray(v)) return v.slice(0);\n  return Object.assign({}, v);\n}\n\nfunction select() {\n  const mapFn1 = selection => () => {\n    const unwrapped = unwrap(selection(), 10),\n          results = [];\n    resolveAsync(unwrapped, value => {\n      if (value === void 0) return;\n\n      for (let key in value || {}) {\n        results.push(diff(value[key], this._state[key], [key]));\n      }\n\n      this.replace([].concat(...results));\n    });\n  };\n\n  const mapFn2 = (key, selector) => () => {\n    const unwrapped = unwrap(selector(), 10);\n    resolveAsync(unwrapped, value => {\n      if (value === void 0) return;\n      this.replace(diff(value, this._state[key], [key]));\n    });\n  };\n\n  for (let i = 0; i < arguments.length; i++) {\n    const selection = arguments[i];\n\n    if (typeof selection === 'function') {\n      s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeComputationNode(mapFn1(selection));\n      continue;\n    }\n\n    for (let key in selection) {\n      if (!(key in this)) this._defineProperty(key);\n      s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeComputationNode(mapFn2(key, selection[key]));\n    }\n  }\n\n  return this;\n}\n\nfunction getDataNode(target) {\n  if (!('_S' in target)) {\n    Object.defineProperty(target, '_S', {\n      value: {}\n    });\n  }\n\n  return target._S;\n}\n\nfunction trigger(node, property, notify) {\n  if (node[property]) node[property].next();\n  if (notify && node._self) node._self.next();\n}\n\nfunction track(target, property) {\n  let value = target[property],\n      node;\n\n  if (Object.isFrozen(value)) {\n    value = clone(value);\n    target[property] = value;\n  }\n\n  if (isObject(value) && !(value instanceof Element)) {\n    if (node = getDataNode(value)) {\n      if (!node._self) node._self = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeDataNode();\n\n      node._self.current();\n    }\n  }\n\n  node = getDataNode(target);\n  node[property] || (node[property] = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeDataNode());\n  node[property].current();\n}\n\nfunction setNested(item, changes) {\n  let node = getDataNode(item),\n      isArray = Array.isArray(item),\n      value,\n      notify,\n      keys;\n\n  if (arguments.length === 3) {\n    notify = isArray || !(arguments[1] in item);\n    value = unwrap(arguments[2]);\n    if (item[arguments[1]] === value) return;\n\n    if (value === void 0) {\n      delete item[arguments[1]];\n      if (isArray) item.length--;\n    } else item[arguments[1]] = value;\n\n    trigger(node, arguments[1], notify);\n    return;\n  }\n\n  keys = Object.keys(changes);\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const property = keys[i];\n    notify = isArray || !(property in item);\n    value = unwrap(changes[property]);\n    if (value === void 0) delete item[property];else item[property] = value;\n    trigger(node, property, notify);\n  }\n}\n\nfunction resolvePath(current, path, length) {\n  let i = 0,\n      temp;\n\n  while (i < length && (temp = current[path[i]]) != null) {\n    current = temp;\n    i++;\n  }\n\n  return current;\n}\n\nfunction sample(target, property) {\n  let value = target[property]; // don't wrap\n\n  if (!isObject(value) || value instanceof Element) return value;\n  return new Proxy(value, proxyTraps);\n}\n\nconst proxyTraps = {\n  get(target, property) {\n    if (property === '_state') return target;\n    if (property === 'sample') return sample.bind(null, target);\n    let value = target[property];\n    if (property === 'length' || typeof property === 'symbol') return value;\n    if (!s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isListening() || typeof value === 'function') return value;\n    track(target, property);\n    return sample(target, property);\n  },\n\n  set() {\n    return true;\n  },\n\n  deleteProperty() {\n    return true;\n  }\n\n};\n\nclass State {\n  constructor(state = {}) {\n    Object.defineProperties(this, {\n      _state: {\n        value: state,\n        writable: true\n      }\n    });\n    this.sample = sample.bind(this, state);\n\n    for (let k in this._state) this._defineProperty(k);\n  }\n\n  set() {\n    const args = arguments;\n    s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].freeze(() => {\n      if (args.length === 1) {\n        if (Array.isArray(args[0])) {\n          for (let i = 0; i < args[0].length; i++) this.set.apply(this, args[0][i]);\n        } else {\n          const keys = Object.keys(args[0]);\n\n          for (let i = 0, l = keys.length; i < l; i++) {\n            const property = keys[i];\n\n            this._setProperty(property, args[0][property]);\n          }\n        }\n\n        return;\n      }\n\n      setNested(resolvePath(this._state, args, args.length - 1), args[args.length - 1]);\n    });\n    return this;\n  }\n\n  replace() {\n    if (arguments.length === 1) {\n      if (!(arguments[0] instanceof Object)) {\n        console.log('replace must be provided a replacement state');\n        return this;\n      }\n\n      let changes = arguments[0];\n      s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].freeze(() => {\n        if (!Array.isArray(changes)) changes = diff(changes, this._state);\n\n        for (let i = 0; i < changes.length; i++) this.replace.apply(this, changes[i]);\n      });\n      return this;\n    }\n\n    if (arguments.length === 2) {\n      this._setProperty.apply(this, arguments);\n\n      return this;\n    }\n\n    const value = arguments[arguments.length - 1],\n          property = arguments[arguments.length - 2];\n    setNested(resolvePath(this._state, arguments, arguments.length - 2), property, value);\n    return this;\n  }\n\n  _setProperty(property, value) {\n    if (!(property in this)) this._defineProperty(property);\n    value = unwrap(value);\n    if (this._state[property] === value) return;\n    if (value === void 0) delete this._state[property];else this._state[property] = value;\n    trigger(getDataNode(this._state), property);\n  }\n\n  _defineProperty(property) {\n    Object.defineProperty(this, property, {\n      get() {\n        const value = this._state[property];\n        if (!s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isListening() || typeof value === 'function') return value;\n        track(this._state, property);\n        return sample(this._state, property);\n      },\n\n      enumerable: true\n    });\n  }\n\n}\n\nState.prototype.select = select;\nvar clockTime = 0;\n\nfunction track$1(target, property, key) {\n  target[property][key] || (target[property][key] = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeDataNode());\n  target[property][key].current();\n}\n\nfunction register(target, property) {\n  if (!target[property]) {\n    target[property] = {\n      _root: target._root || target,\n      _clock: clockTime,\n      _path: target._path.concat([property]),\n      _state: target._state[property]\n    };\n  }\n}\n\nfunction sample$1(target, property) {\n  let value = target._state[property];\n\n  if (isObject(value) && !(value instanceof Element)) {\n    register(target, property);\n    value = new Proxy(target[property], proxyTraps$1);\n  }\n\n  return value;\n}\n\nfunction resolveState(target) {\n  var current = target._root._state,\n      i = 0,\n      l = target._path.length;\n\n  while (i < l) {\n    if (current) current = current[target._path[i]];\n    i++;\n  }\n\n  target._state = current;\n  target._clock = clockTime;\n}\n\nconst proxyTraps$1 = {\n  set() {\n    return true;\n  },\n\n  deleteProperty() {\n    return true;\n  },\n\n  has(target, property) {\n    if (target._clock < clockTime) resolveState(target);\n    return Reflect.has(target._state, property);\n  },\n\n  ownKeys(target) {\n    if (target._clock < clockTime) resolveState(target);\n    return Reflect.ownKeys(target._state);\n  },\n\n  getOwnPropertyDescriptor(target, property) {\n    if (target._clock < clockTime) resolveState(target);\n    var descriptors = Reflect.getOwnPropertyDescriptor(target._state, property); // hack for invariant\n\n    descriptors.configurable = true;\n    return descriptors;\n  },\n\n  get(target, property) {\n    var value;\n    if (target._clock < clockTime) resolveState(target);\n    if (property === '_state') return target._state;\n    if (property === 'sample') return sample$1.bind(null, target);\n    if (property === 'length' || typeof property === 'symbol') return target._state[property];\n\n    if (property.endsWith('$')) {\n      property = property.slice(0, -1);\n      value = target._state[property];\n      if (!s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isListening() || typeof value === 'function') return value;\n      register(target, property);\n      track$1(target, property, '_subTree');\n      return value;\n    }\n\n    value = target._state[property];\n    if (!s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isListening() || typeof value === 'function') return value;\n    register(target, property);\n    track$1(target, property, '_self');\n    if (isObject(value) && !(value instanceof Element)) value = new Proxy(target[property], proxyTraps$1);\n    return value;\n  }\n\n};\n\nclass ImmutableState {\n  constructor(state = {}) {\n    Object.defineProperties(this, {\n      _state: {\n        value: state,\n        writable: true\n      },\n      _nodes: {\n        value: {\n          _path: [],\n          _state: state\n        },\n        writable: true\n      }\n    });\n    this.select = select.bind(this);\n    this.sample = sample$1.bind(this, this._nodes);\n\n    for (var k in this._state) this._defineProperty(k);\n  }\n\n  set() {\n    var args = arguments,\n        ref,\n        clearMutation = !ImmutableState.inMutation;\n    if (clearMutation) clockTime++;\n    ImmutableState.inMutation = true;\n    s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].freeze(() => {\n      if (args.length === 1) {\n        if (Array.isArray(args[0])) for (let i = 0; i < args[0]; i++) this.set.apply(this, args[0][i]);else for (let property in args[0]) this._setProperty(property, args[0][property]);\n        return;\n      }\n\n      var changes = args[args.length - 1],\n          notify,\n          value,\n          property,\n          {\n        state,\n        subs,\n        subPaths\n      } = this._resolvePath(args, args.length - 1);\n\n      if (!state) return;\n      notify = Array.isArray(state);\n\n      for (property in changes) {\n        value = unwrap(changes[property]);\n        if (state[property] === value) continue;\n        notify = notify || !(property in state);\n        if (value === void 0) delete state[property];else state[property] = value;\n        if (subs) (ref = subs[property]) != null && ref._self ? ref._self.next() : void 0;\n      }\n\n      if (notify && subs && subs._self) subs._self.next();\n\n      for (let i = 0; i < subPaths.length; i++) subPaths[i].next();\n    });\n    if (clearMutation) ImmutableState.inMutation = false;\n    return this;\n  }\n\n  replace() {\n    var ref,\n        clearMutation = !ImmutableState.inMutation;\n    if (clearMutation) clockTime++;\n    ImmutableState.inMutation = true;\n\n    if (arguments.length === 1) {\n      if (!(arguments[0] instanceof Object)) {\n        console.log('replace must be provided a replacement state');\n        if (clearMutation) ImmutableState.inMutation = false;\n        return this;\n      }\n\n      var changes = arguments[0];\n      s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].freeze(() => {\n        if (!Array.isArray(changes)) changes = diff(changes, this._state);\n\n        for (let i = 0; i < changes.length; i++) this.replace.apply(this, changes[i]);\n      });\n      if (clearMutation) ImmutableState.inMutation = false;\n      return this;\n    }\n\n    if (arguments.length === 2) {\n      this._setProperty.apply(this, arguments);\n\n      if (clearMutation) ImmutableState.inMutation = false;\n      return this;\n    }\n\n    var value = unwrap(arguments[arguments.length - 1]),\n        property = arguments[arguments.length - 2],\n        notify,\n        {\n      state,\n      subs,\n      subPaths\n    } = this._resolvePath(arguments, arguments.length - 2);\n\n    if (!state || state[property] === value) return;\n\n    if (value === void 0 && Array.isArray(state)) {\n      state.length -= 1;\n      notify = true;\n    } else {\n      notify = Array.isArray(state) || !(property in state);\n      if (value === void 0) delete state[property];else state[property] = value;\n    }\n\n    if (subs && subs[property] && (ref = subs[property]._self)) ref.next();\n    if (notify && subs && subs._self) subs._self.next();\n\n    for (let i = 0; i < subPaths.length; i++) subPaths[i].next();\n\n    if (clearMutation) ImmutableState.inMutation = false;\n    return this;\n  }\n\n  _resolvePath(path, length) {\n    var currentState = this._state,\n        currentSubs = this._nodes,\n        subPaths = [],\n        i = 0;\n\n    while (i < length) {\n      register(currentSubs, path[i]);\n      currentSubs = currentSubs[path[i]];\n\n      if (currentState != null) {\n        if (currentSubs._clock !== clockTime) {\n          currentState[path[i]] = clone(currentState[path[i]]);\n          currentSubs._clock = clockTime;\n          currentSubs._state = currentState[path[i]];\n        }\n\n        currentState = currentState[path[i]];\n      }\n\n      if ((currentSubs != null ? currentSubs._subTree : void 0) != null) subPaths.push(currentSubs._subTree);\n      i++;\n    }\n\n    return {\n      state: currentState,\n      subs: currentSubs,\n      subPaths\n    };\n  }\n\n  _setProperty(property, value) {\n    var ref;\n    if (!(property in this)) this._defineProperty(property);\n    value = unwrap(value);\n    if (this._state[property] === value) return;\n    if (value === void 0) delete this._state[property];else this._state[property] = value;\n    (ref = this._nodes[property]) != null && ref._self ? ref._self.next() : void 0;\n    ref && ref._subTree ? ref._subTree.next() : void 0;\n  }\n\n  _defineProperty(property) {\n    Object.defineProperty(this, property, {\n      get() {\n        var value = this._state[property];\n        if (!s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isListening() || typeof value === 'function') return value;\n        register(this._nodes, property);\n        track$1(this._nodes, property, '_self');\n        if (isObject(value) && !(value instanceof Element)) value = new Proxy(this._nodes[property], proxyTraps$1);\n        return value;\n      },\n\n      enumerable: true\n    });\n    Object.defineProperty(this, property + '$', {\n      get() {\n        var value = this._state[property];\n        if (!s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isListening()) return value;\n        register(this._nodes, property);\n        track$1(this._nodes, property, '_subTree');\n        return value;\n      }\n\n    });\n  }\n\n}\n\nImmutableState.inMutation = false;\n\nfunction fromPromise(promise, seed) {\n  let s = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeDataNode(seed),\n      complete = false;\n  promise.then(value => {\n    if (complete) return;\n    s.next(value);\n  }).catch(err => console.error(err));\n  s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cleanup(function dispose() {\n    complete = true;\n  });\n  return () => s.current();\n}\n\nfunction fromObservable(observable, seed) {\n  let s = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].makeDataNode(seed),\n      disposable = observable.subscribe(v => s.next(v), err => console.error(err));\n  s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cleanup(function dispose() {\n    disposable.unsubscribe();\n    disposable = null;\n  });\n  return () => s.current();\n}\n\nfunction from(input, seed) {\n  if (isObject(input)) {\n    if (typeof input === 'function') return input;\n    if (Symbol.observable in input) return fromObservable(input[Symbol.observable](), seed);\n    if ('then' in input) return fromPromise(input, seed);\n  }\n\n  throw new Error('from() input must be a function, Promise, or Observable');\n}\n\nfunction pipe(input, ...fns) {\n  return compose(...fns)(input);\n}\n\nfunction map(fn) {\n  return input => () => {\n    const value = input();\n    if (value === void 0) return;\n    return s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sample(() => fn(value));\n  };\n}\n\nfunction compose(...fns) {\n  if (!fns) return i => i;\n  if (fns.length === 1) return fns[0];\n  return input => fns.reduce((prev, fn) => fn(prev), input);\n} // memoized map that handles falsey rejection\n\n\nfunction when(mapFn) {\n  let mapped, value, disposable;\n  s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cleanup(function dispose() {\n    disposable && disposable();\n  });\n  return map(function mapper(newValue) {\n    if (newValue == null || newValue === false) {\n      disposable && disposable();\n      return value = mapped = disposable = null;\n    }\n\n    if (value === newValue) return mapped;\n    disposable && disposable();\n    disposable = null;\n    value = newValue;\n    return mapped = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].root(d => {\n      disposable = d;\n      return mapFn(value);\n    });\n  });\n} // Need to be able grab wrapped state internals so can't use S-Array\n\n\nfunction each(mapFn) {\n  let mapped = [],\n      list = [],\n      disposables = [],\n      length = 0;\n  s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cleanup(function dispose() {\n    for (let i = 0; i < disposables.length; i++) disposables[i]();\n  });\n  return map(function mapper(newList) {\n    let newListUnwrapped = unwrap(newList, 1),\n        i,\n        j = 0,\n        newLength = newListUnwrapped && newListUnwrapped.length || 0;\n\n    if (newLength === 0) {\n      if (length !== 0) {\n        for (i = 0; i < length; i++) disposables[i]();\n\n        list = [];\n        mapped = [];\n        disposables = [];\n        length = 0;\n      }\n    } else if (length === 0) {\n      j = 0;\n\n      while (j < newLength) {\n        list[j] = newListUnwrapped[j];\n        mapped[j] = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].root(mappedFn);\n        j++;\n      }\n\n      length = newLength;\n    } else {\n      const newMapped = new Array(newLength),\n            tempDisposables = new Array(newLength),\n            indexedItems = new Map(); // reduce from both ends\n\n      let end = Math.min(length, newLength),\n          start = 0,\n          item,\n          itemIndex,\n          newEnd;\n\n      while (start < end && newListUnwrapped[start] === list[start]) start++;\n\n      end = length - 1;\n      newEnd = newLength - 1;\n\n      while (end >= 0 && newEnd >= 0 && newListUnwrapped[newEnd] === list[end]) {\n        newMapped[newEnd] = mapped[end];\n        tempDisposables[newEnd] = disposables[end];\n        end--;\n        newEnd--;\n      } // create indices\n\n\n      j = newEnd;\n\n      while (j >= start) {\n        item = newListUnwrapped[j];\n        itemIndex = indexedItems.get(item);\n        if (itemIndex != null) itemIndex.push(j);else indexedItems.set(item, [j]);\n        j--;\n      } // find old items\n\n\n      i = start;\n\n      while (i <= end) {\n        item = list[i];\n        itemIndex = indexedItems.get(item);\n\n        if (itemIndex != null && itemIndex.length > 0) {\n          j = itemIndex.pop();\n          newMapped[j] = mapped[i];\n          tempDisposables[j] = disposables[i];\n        } else disposables[i]();\n\n        i++;\n      } // set all new values\n\n\n      j = start;\n\n      while (j < newLength) {\n        if (newMapped.hasOwnProperty(j)) {\n          mapped[j] = newMapped[j];\n          disposables[j] = tempDisposables[j];\n        } else mapped[j] = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].root(mappedFn);\n\n        j++;\n      } // truncate extra length\n\n\n      length = mapped.length = disposables.length = newLength; // save list for next iteration\n\n      list = newListUnwrapped.slice(0);\n    }\n\n    return mapped;\n\n    function mappedFn(dispose) {\n      let ref;\n      disposables[j] = dispose;\n      const row = (ref = newList.sample) ? ref(j) : newList[j];\n      return mapFn(row, j);\n    }\n  });\n} // export observable\n\n\nfunction observable(input) {\n  if (Symbol.observable in input) return input[Symbol.observable]();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError('Expected the observer to be an object.');\n      }\n\n      observer = observer.next || observer;\n      let complete = false;\n      s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].on(input, function next() {\n        if (complete) return;\n        observer(input());\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n\n      };\n    },\n\n    [Symbol.observable]() {\n      return this;\n    }\n\n  };\n}\n\nconst root = s_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].root;\n\n\n//# sourceURL=webpack:///./node_modules/solid-js/dist/solid.js?");

/***/ }),

/***/ "./src/App.jsx":
/*!*********************!*\
  !*** ./src/App.jsx ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js */ \"./node_modules/solid-js/dist/solid.js\");\n/* harmony import */ var solid_js_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! solid-js/dom */ \"./node_modules/solid-js/dist/dom.js\");\nconst _tmpl$7 = document.createElement(\"template\");\n\n_tmpl$7.innerHTML = \"<button class='clear-completed'>Clear completed</button>\";\n\nconst _tmpl$6 = document.createElement(\"template\");\n\n_tmpl$6.innerHTML = \"<footer class='footer'><span class='todo-count'><strong></strong> left\\n    </span><ul class='filters'><li><a href='#/'>All</a></li><span></span><li><a href='#/active'>Active</a></li><span></span><li><a href='#/completed'>Completed</a></li></ul></footer>\";\n\nconst _tmpl$5 = document.createElement(\"template\");\n\n_tmpl$5.innerHTML = \"<input class='edit'/>\";\n\nconst _tmpl$4 = document.createElement(\"template\");\n\n_tmpl$4.innerHTML = \"<li class='todo'><div class='view'><input class='toggle' type='checkbox'/><label></label><button class='destroy'></button></div></li>\";\n\nconst _tmpl$3 = document.createElement(\"template\");\n\n_tmpl$3.innerHTML = \"<section class='main'><input id='toggle-all' class='toggle-all' type='checkbox'/><label for='toggle-all'></label><ul class='todo-list'></ul></section>\";\n\nconst _tmpl$2 = document.createElement(\"template\");\n\n_tmpl$2.innerHTML = \"<header class='header'><h1>todos</h1><input class='new-todo' placeholder='What needs to be done?'/></header>\";\n\nconst _tmpl$ = document.createElement(\"template\");\n\n_tmpl$.innerHTML = \"<section class='todoapp'></section>\";\n\n\nconst ESCAPE_KEY = 27,\n      ENTER_KEY = 13;\n\nconst TodoApp = props => function () {\n  const _el$ = _tmpl$.content.firstChild.cloneNode(true),\n        _el$2 = _el$.insertBefore(document.createTextNode(\"\"), _el$.firstChild),\n        _el$3 = _el$.insertBefore(document.createTextNode(\"\"), _el$2.nextSibling),\n        _el$4 = _el$.insertBefore(document.createTextNode(\"\"), _el$3.nextSibling);\n\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insertM(_el$, TodoHeader(props), _el$2);\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insertM(_el$, () => Object(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"when\"])(() => TodoList(props))(() => props.state.todos.length > 0), _el$3);\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insertM(_el$, () => Object(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"when\"])(() => TodoFooter(props))(() => props.state.todos.length > 0), _el$4);\n  return _el$;\n}();\n\nconst TodoHeader = ({\n  addTodo\n}) => function () {\n  const _el$5 = _tmpl$2.content.firstChild.cloneNode(true),\n        _el$6 = _el$5.firstChild,\n        _el$7 = _el$6.nextSibling;\n\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$7, \"keyup\", ({\n    target,\n    keyCode\n  }) => {\n    let title;\n    if (!(keyCode === ENTER_KEY && (title = target.value.trim()))) return;\n    addTodo({\n      title\n    });\n    target.value = '';\n  });\n  return _el$5;\n}();\n\nconst TodoList = props => {\n  const {\n    state,\n    toggleAll\n  } = props;\n\n  function filterList(todos) {\n    if (state.showMode === 'active') return todos.filter(todo => !todo.completed);else if (state.showMode === 'completed') return todos.filter(todo => todo.completed);else return todos;\n  }\n\n  return function () {\n    const _el$8 = _tmpl$3.content.firstChild.cloneNode(true),\n          _el$9 = _el$8.firstChild,\n          _el$10 = _el$9.nextSibling,\n          _el$11 = _el$10.nextSibling;\n\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => _el$9.checked = !state.remainingCount);\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$9, \"change\", ({\n      target: {\n        checked\n      }\n    }) => toggleAll(checked));\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insert(_el$11, () => Object(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"each\"])(todo => TodoItem(Object.assign(props, {\n      todo: todo\n    })))(() => filterList(state.todos)));\n    return _el$8;\n  }();\n};\n\nconst TodoItem = ({\n  state,\n  editTodo,\n  removeTodo,\n  todo\n}) => {\n  function onSave({\n    target: {\n      value\n    }\n  }) {\n    let title;\n    if (!(state.edittingTodoId === todo.id && (title = value.trim()))) return;\n    editTodo({\n      id: todo.id,\n      title\n    });\n    state.set({\n      edittingTodoId: null\n    });\n  }\n\n  return function () {\n    const _el$12 = _tmpl$4.content.firstChild.cloneNode(true),\n          _el$13 = _el$12.firstChild,\n          _el$14 = _el$13.firstChild,\n          _el$15 = _el$14.nextSibling,\n          _el$16 = _el$15.nextSibling,\n          _el$17 = _el$12.insertBefore(document.createTextNode(\"\"), _el$13.nextSibling);\n\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => {\n      let classNames = {\n        completed: todo.completed,\n        editing: todo.id === state.edittingTodoId\n      };\n      let classKeys = Object.keys(classNames);\n\n      for (let i = 0; i < classKeys.length; i++) _el$12.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n    });\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => _el$14.checked = todo.completed);\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$14, \"change\", ({\n      target: {\n        checked\n      }\n    }) => editTodo({\n      id: todo.id,\n      completed: checked\n    }));\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$15, \"dblclick\", () => state.set({\n      edittingTodoId: todo.id\n    }));\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insert(_el$15, () => todo.title);\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$16, \"click\", () => removeTodo(todo.id));\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insertM(_el$12, () => todo.id === state.edittingTodoId && function () {\n      const _el$18 = _tmpl$5.content.firstChild.cloneNode(true);\n\n      solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => _el$18.value = todo.title);\n      solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$18, \"blur\", onSave);\n      solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$18, \"keyup\", e => {\n        if (e.keyCode === ENTER_KEY) onSave(e);else if (e.keyCode === ESCAPE_KEY) state.set({\n          edittingTodoId: null\n        });\n      });\n      return _el$18;\n    }(), _el$17);\n    return _el$12;\n  }();\n};\n\nconst TodoFooter = ({\n  state,\n  clearCompleted\n}) => function () {\n  const _el$19 = _tmpl$6.content.firstChild.cloneNode(true),\n        _el$20 = _el$19.firstChild,\n        _el$21 = _el$20.firstChild,\n        _el$22 = _el$20.insertBefore(document.createTextNode(\"\"), _el$21.nextSibling),\n        _el$23 = _el$20.nextSibling,\n        _el$24 = _el$23.firstChild,\n        _el$25 = _el$24.firstChild,\n        _el$26 = _el$24.nextSibling,\n        _el$27 = _el$26.nextSibling,\n        _el$28 = _el$27.firstChild,\n        _el$29 = _el$27.nextSibling,\n        _el$30 = _el$29.nextSibling,\n        _el$31 = _el$30.firstChild,\n        _el$32 = _el$19.insertBefore(document.createTextNode(\"\"), _el$23.nextSibling);\n\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insert(_el$21, () => state.remainingCount);\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insertM(_el$20, () => state.remainingCount === 1 ? ' item' : ' items', _el$22);\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => {\n    let classNames = {\n      selected: state.showMode === 'all'\n    };\n    let classKeys = Object.keys(classNames);\n\n    for (let i = 0; i < classKeys.length; i++) _el$25.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n  });\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => {\n    let classNames = {\n      selected: state.showMode === 'active'\n    };\n    let classKeys = Object.keys(classNames);\n\n    for (let i = 0; i < classKeys.length; i++) _el$28.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n  });\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].wrap(() => {\n    let classNames = {\n      selected: state.showMode === 'completed'\n    };\n    let classKeys = Object.keys(classNames);\n\n    for (let i = 0; i < classKeys.length; i++) _el$31.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n  });\n  solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].insertM(_el$19, () => Object(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"when\"])(() => function () {\n    const _el$33 = _tmpl$7.content.firstChild.cloneNode(true);\n\n    solid_js_dom__WEBPACK_IMPORTED_MODULE_1__[\"r\"].addEventListener(_el$33, \"click\", () => clearCompleted());\n    return _el$33;\n  }())(() => state.completedCount > 0), _el$32);\n  return _el$19;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TodoApp);\n\n//# sourceURL=webpack:///./src/App.jsx?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js */ \"./node_modules/solid-js/dist/solid.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App */ \"./src/App.jsx\");\n/* harmony import */ var _mapToProps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mapToProps */ \"./src/mapToProps.js\");\n\n\n\nObject(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"root\"])(() => document.body.appendChild(Object(_App__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Object(_mapToProps__WEBPACK_IMPORTED_MODULE_2__[\"default\"])())));\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/mapToProps.js":
/*!***************************!*\
  !*** ./src/mapToProps.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var solid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! solid-js */ \"./node_modules/solid-js/dist/solid.js\");\n/* harmony import */ var s_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! s-js */ \"./node_modules/s-js/dist/es/S.js\");\n\n\nconst LOCAL_STORAGE_KEY = 'todos-solid';\n\nfunction setupPersistence(state) {\n  // load stored todos on init\n  const stored = localStorage.getItem(LOCAL_STORAGE_KEY);\n  if (stored) state.replace(JSON.parse(stored)); // JSON.stringify creates deps on every iterable field\n\n  s_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].effect(() => {\n    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));\n  });\n} // event wrapper\n\n\nfunction fromEvent(el, eventName, seed) {\n  const s = s_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].data(seed);\n  el.addEventListener(eventName, s);\n  s_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].cleanup(() => el.removeEventListener(eventName, s));\n  return s;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (() => {\n  const state = new solid_js__WEBPACK_IMPORTED_MODULE_0__[\"State\"]({\n    counter: 0,\n    edittingTodoId: null,\n    todos: []\n  });\n  setupPersistence(state);\n  state.select({\n    completedCount() {\n      return state.todos.filter(todo => todo.completed).length;\n    },\n\n    remainingCount() {\n      return state.todos.length - (state.completedCount || 0);\n    },\n\n    showMode: Object(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"pipe\"])(fromEvent(window, 'hashchange', 1), Object(solid_js__WEBPACK_IMPORTED_MODULE_0__[\"map\"])(() => location.hash.slice(2) || 'all'))\n  });\n  return {\n    state,\n    addTodo: ({\n      title\n    }) => {\n      const id = state.counter + 1;\n      state.set({\n        todos: [{\n          title,\n          id,\n          completed: false\n        }, ...state.todos],\n        counter: id\n      });\n    },\n    removeTodo: todoId => state.set({\n      todos: state.todos.filter(item => item.id !== todoId)\n    }),\n    editTodo: todo => {\n      const index = state.todos.findIndex(item => item.id === todo.id);\n      state.set('todos', index, todo);\n    },\n    clearCompleted: () => state.set({\n      todos: state.todos.filter(todo => !todo.completed)\n    }),\n    toggleAll: completed => {\n      state.todos.forEach((todo, index) => todo.completed !== completed && state.set('todos', index, {\n        completed\n      }));\n    }\n  };\n});\n\n//# sourceURL=webpack:///./src/mapToProps.js?");

/***/ })

/******/ });