!function(n){var g={};function I(t){if(g[t])return g[t].exports;var e=g[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,I),e.l=!0,e.exports}I.m=n,I.c=g,I.d=function(n,g,t){I.o(n,g)||Object.defineProperty(n,g,{enumerable:!0,get:t})},I.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},I.t=function(n,g){if(1&g&&(n=I(n)),8&g)return n;if(4&g&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(I.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&g&&"string"!=typeof n)for(var e in n)I.d(t,e,function(g){return n[g]}.bind(null,e));return t},I.n=function(n){var g=n&&n.__esModule?function(){return n.default}:function(){return n};return I.d(g,"a",g),g},I.o=function(n,g){return Object.prototype.hasOwnProperty.call(n,g)},I.p="/",I(I.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/s-js/dist/es/S.js\n// Public interface\nvar S_S = function S(fn, value) {\n  var node = new ComputationNode(fn, value);\n  return function computation() {\n    return node.current();\n  };\n}; // compatibility with commonjs systems that expect default export to be at require('s.js').default rather than just require('s-js')\n\n\nObject.defineProperty(S_S, 'default', {\n  value: S_S\n});\n/* harmony default export */ var es_S = (S_S);\n\nS_S.root = function root(fn) {\n  var owner = Owner,\n      root = fn.length === 0 ? UNOWNED : new ComputationNode(null, null),\n      result = undefined,\n      disposer = fn.length === 0 ? null : function _dispose() {\n    if (RunningClock !== null) {\n      RootClock.disposes.add(root);\n    } else {\n      dispose(root);\n    }\n  };\n  Owner = root;\n\n  if (RunningClock === null) {\n    result = topLevelRoot(fn, disposer, owner);\n  } else {\n    result = disposer === null ? fn() : fn(disposer);\n    Owner = owner;\n  }\n\n  return result;\n};\n\nfunction topLevelRoot(fn, disposer, owner) {\n  try {\n    return disposer === null ? fn() : fn(disposer);\n  } finally {\n    Owner = owner;\n  }\n}\n\nS_S.on = function on(ev, fn, seed, onchanges) {\n  if (Array.isArray(ev)) ev = callAll(ev);\n  onchanges = !!onchanges;\n  return S_S(on, seed);\n\n  function on(value) {\n    var running = RunningNode;\n    ev();\n    if (onchanges) onchanges = false;else {\n      RunningNode = null;\n      value = fn(value);\n      RunningNode = running;\n    }\n    return value;\n  }\n};\n\nfunction callAll(ss) {\n  return function all() {\n    for (var i = 0; i < ss.length; i++) ss[i]();\n  };\n}\n\nS_S.effect = function effect(fn, value) {\n  new ComputationNode(fn, value);\n};\n\nS_S.data = function data(value) {\n  var node = new DataNode(value);\n  return function data(value) {\n    if (arguments.length === 0) {\n      return node.current();\n    } else {\n      return node.next(value);\n    }\n  };\n};\n\nS_S.value = function value(current, eq) {\n  var data = S_S.data(current),\n      age = -1;\n  return function value(update) {\n    if (arguments.length === 0) {\n      return data();\n    } else {\n      var same = eq ? eq(current, update) : current === update;\n\n      if (!same) {\n        var time = RootClock.time;\n        if (age === time) throw new Error(\"conflicting values: \" + update + \" is not the same as \" + current);\n        age = time;\n        current = update;\n        data(update);\n      }\n\n      return update;\n    }\n  };\n};\n\nS_S.freeze = function freeze(fn) {\n  var result = undefined;\n\n  if (RunningClock !== null) {\n    result = fn();\n  } else {\n    RunningClock = RootClock;\n    RunningClock.changes.reset();\n\n    try {\n      result = fn();\n      S_event();\n    } finally {\n      RunningClock = null;\n    }\n  }\n\n  return result;\n};\n\nS_S.sample = function sample(fn) {\n  var result,\n      running = RunningNode;\n\n  if (running !== null) {\n    RunningNode = null;\n    result = fn();\n    RunningNode = running;\n  } else {\n    result = fn();\n  }\n\n  return result;\n};\n\nS_S.cleanup = function cleanup(fn) {\n  if (Owner !== null) {\n    if (Owner.cleanups === null) Owner.cleanups = [fn];else Owner.cleanups.push(fn);\n  } else {\n    console.warn(\"cleanups created without a root or parent will never be run\");\n  }\n}; // experimental : exposing node constructors and some state\n\n\nS_S.makeDataNode = function makeDataNode(value) {\n  return new DataNode(value);\n};\n\nS_S.makeComputationNode = function makeComputationNode(fn, seed) {\n  return new ComputationNode(fn, seed);\n};\n\nS_S.isFrozen = function isFrozen() {\n  return RunningClock !== null;\n};\n\nS_S.isListening = function isListening() {\n  return RunningNode !== null;\n}; // Internal implementation\n/// Graph classes and operations\n\n\nvar Clock =\n/** @class */\nfunction () {\n  function Clock() {\n    this.time = 0;\n    this.changes = new Queue(); // batched changes to data nodes\n\n    this.updates = new Queue(); // computations to update\n\n    this.disposes = new Queue(); // disposals to run after current batch of updates finishes\n  }\n\n  return Clock;\n}();\n\nvar RootClockProxy = {\n  time: function () {\n    return RootClock.time;\n  }\n};\n\nvar DataNode =\n/** @class */\nfunction () {\n  function DataNode(value) {\n    this.value = value;\n    this.pending = NOTPENDING;\n    this.log = null;\n  }\n\n  DataNode.prototype.current = function () {\n    if (RunningNode !== null) {\n      logDataRead(this, RunningNode);\n    }\n\n    return this.value;\n  };\n\n  DataNode.prototype.next = function (value) {\n    if (RunningClock !== null) {\n      if (this.pending !== NOTPENDING) {\n        // value has already been set once, check for conflicts\n        if (value !== this.pending) {\n          throw new Error(\"conflicting changes: \" + value + \" !== \" + this.pending);\n        }\n      } else {\n        // add to list of changes\n        this.pending = value;\n        RootClock.changes.add(this);\n      }\n    } else {\n      // not batching, respond to change now\n      if (this.log !== null) {\n        this.pending = value;\n        RootClock.changes.add(this);\n        S_event();\n      } else {\n        this.value = value;\n      }\n    }\n\n    return value;\n  };\n\n  DataNode.prototype.clock = function () {\n    return RootClockProxy;\n  };\n\n  return DataNode;\n}();\n\nvar ComputationNode =\n/** @class */\nfunction () {\n  function ComputationNode(fn, value) {\n    this.state = CURRENT;\n    this.source1 = null;\n    this.source1slot = 0;\n    this.sources = null;\n    this.sourceslots = null;\n    this.log = null;\n    this.owned = null;\n    this.cleanups = null;\n    this.fn = fn;\n    this.value = value;\n    this.age = RootClock.time;\n    if (fn === null) return;\n    var owner = Owner,\n        running = RunningNode;\n    if (owner === null) console.warn(\"computations created without a root or parent will never be disposed\");\n    Owner = RunningNode = this;\n\n    if (RunningClock === null) {\n      toplevelComputation(this);\n    } else {\n      this.value = this.fn(this.value);\n    }\n\n    if (owner && owner !== UNOWNED) {\n      if (owner.owned === null) owner.owned = [this];else owner.owned.push(this);\n    }\n\n    Owner = owner;\n    RunningNode = running;\n  }\n\n  ComputationNode.prototype.current = function () {\n    if (RunningNode !== null) {\n      if (this.age === RootClock.time) {\n        if (this.state === RUNNING) throw new Error(\"circular dependency\");else updateNode(this); // checks for state === STALE internally, so don't need to check here\n      }\n\n      logComputationRead(this, RunningNode);\n    }\n\n    return this.value;\n  };\n\n  ComputationNode.prototype.clock = function () {\n    return RootClockProxy;\n  };\n\n  return ComputationNode;\n}();\n\nvar Log =\n/** @class */\nfunction () {\n  function Log() {\n    this.node1 = null;\n    this.node1slot = 0;\n    this.nodes = null;\n    this.nodeslots = null;\n  }\n\n  return Log;\n}();\n\nvar Queue =\n/** @class */\nfunction () {\n  function Queue() {\n    this.items = [];\n    this.count = 0;\n  }\n\n  Queue.prototype.reset = function () {\n    this.count = 0;\n  };\n\n  Queue.prototype.add = function (item) {\n    this.items[this.count++] = item;\n  };\n\n  Queue.prototype.run = function (fn) {\n    var items = this.items;\n\n    for (var i = 0; i < this.count; i++) {\n      fn(items[i]);\n      items[i] = null;\n    }\n\n    this.count = 0;\n  };\n\n  return Queue;\n}(); // Constants\n\n\nvar NOTPENDING = {},\n    CURRENT = 0,\n    STALE = 1,\n    RUNNING = 2; // \"Globals\" used to keep track of current system state\n\nvar RootClock = new Clock(),\n    RunningClock = null,\n    // currently running clock \nRunningNode = null,\n    // currently running computation\nOwner = null,\n    // owner for new computations\nUNOWNED = new ComputationNode(null, null); // Functions\n\nfunction logRead(from, to) {\n  var fromslot,\n      toslot = to.source1 === null ? -1 : to.sources === null ? 0 : to.sources.length;\n\n  if (from.node1 === null) {\n    from.node1 = to;\n    from.node1slot = toslot;\n    fromslot = -1;\n  } else if (from.nodes === null) {\n    from.nodes = [to];\n    from.nodeslots = [toslot];\n    fromslot = 0;\n  } else {\n    fromslot = from.nodes.length;\n    from.nodes.push(to);\n    from.nodeslots.push(toslot);\n  }\n\n  if (to.source1 === null) {\n    to.source1 = from;\n    to.source1slot = fromslot;\n  } else if (to.sources === null) {\n    to.sources = [from];\n    to.sourceslots = [fromslot];\n  } else {\n    to.sources.push(from);\n    to.sourceslots.push(fromslot);\n  }\n}\n\nfunction logDataRead(data, to) {\n  if (data.log === null) data.log = new Log();\n  logRead(data.log, to);\n}\n\nfunction logComputationRead(node, to) {\n  if (node.log === null) node.log = new Log();\n  logRead(node.log, to);\n}\n\nfunction S_event() {\n  // b/c we might be under a top level S.root(), have to preserve current root\n  var owner = Owner;\n  RootClock.updates.reset();\n  RootClock.time++;\n\n  try {\n    run(RootClock);\n  } finally {\n    RunningClock = RunningNode = null;\n    Owner = owner;\n  }\n}\n\nfunction toplevelComputation(node) {\n  RunningClock = RootClock;\n  RootClock.changes.reset();\n  RootClock.updates.reset();\n\n  try {\n    node.value = node.fn(node.value);\n\n    if (RootClock.changes.count > 0 || RootClock.updates.count > 0) {\n      RootClock.time++;\n      run(RootClock);\n    }\n  } finally {\n    RunningClock = Owner = RunningNode = null;\n  }\n}\n\nfunction run(clock) {\n  var running = RunningClock,\n      count = 0;\n  RunningClock = clock;\n  clock.disposes.reset(); // for each batch ...\n\n  while (clock.changes.count !== 0 || clock.updates.count !== 0 || clock.disposes.count !== 0) {\n    if (count > 0) // don't tick on first run, or else we expire already scheduled updates\n      clock.time++;\n    clock.changes.run(applyDataChange);\n    clock.updates.run(updateNode);\n    clock.disposes.run(dispose); // if there are still changes after excessive batches, assume runaway            \n\n    if (count++ > 1e5) {\n      throw new Error(\"Runaway clock detected\");\n    }\n  }\n\n  RunningClock = running;\n}\n\nfunction applyDataChange(data) {\n  data.value = data.pending;\n  data.pending = NOTPENDING;\n  if (data.log) markComputationsStale(data.log);\n}\n\nfunction markComputationsStale(log) {\n  var node1 = log.node1,\n      nodes = log.nodes; // mark all downstream nodes stale which haven't been already\n\n  if (node1 !== null) markNodeStale(node1);\n\n  if (nodes !== null) {\n    for (var i = 0, len = nodes.length; i < len; i++) {\n      markNodeStale(nodes[i]);\n    }\n  }\n}\n\nfunction markNodeStale(node) {\n  var time = RootClock.time;\n\n  if (node.age < time) {\n    node.age = time;\n    node.state = STALE;\n    RootClock.updates.add(node);\n    if (node.owned !== null) markOwnedNodesForDisposal(node.owned);\n    if (node.log !== null) markComputationsStale(node.log);\n  }\n}\n\nfunction markOwnedNodesForDisposal(owned) {\n  for (var i = 0; i < owned.length; i++) {\n    var child = owned[i];\n    child.age = RootClock.time;\n    child.state = CURRENT;\n    if (child.owned !== null) markOwnedNodesForDisposal(child.owned);\n  }\n}\n\nfunction updateNode(node) {\n  if (node.state === STALE) {\n    var owner = Owner,\n        running = RunningNode;\n    Owner = RunningNode = node;\n    node.state = RUNNING;\n    cleanup(node, false);\n    node.value = node.fn(node.value);\n    node.state = CURRENT;\n    Owner = owner;\n    RunningNode = running;\n  }\n}\n\nfunction cleanup(node, final) {\n  var source1 = node.source1,\n      sources = node.sources,\n      sourceslots = node.sourceslots,\n      cleanups = node.cleanups,\n      owned = node.owned,\n      i,\n      len;\n\n  if (cleanups !== null) {\n    for (i = 0; i < cleanups.length; i++) {\n      cleanups[i](final);\n    }\n\n    node.cleanups = null;\n  }\n\n  if (owned !== null) {\n    for (i = 0; i < owned.length; i++) {\n      dispose(owned[i]);\n    }\n\n    node.owned = null;\n  }\n\n  if (source1 !== null) {\n    cleanupSource(source1, node.source1slot);\n    node.source1 = null;\n  }\n\n  if (sources !== null) {\n    for (i = 0, len = sources.length; i < len; i++) {\n      cleanupSource(sources.pop(), sourceslots.pop());\n    }\n  }\n}\n\nfunction cleanupSource(source, slot) {\n  var nodes = source.nodes,\n      nodeslots = source.nodeslots,\n      last,\n      lastslot;\n\n  if (slot === -1) {\n    source.node1 = null;\n  } else {\n    last = nodes.pop();\n    lastslot = nodeslots.pop();\n\n    if (slot !== nodes.length) {\n      nodes[slot] = last;\n      nodeslots[slot] = lastslot;\n\n      if (lastslot === -1) {\n        last.source1slot = slot;\n      } else {\n        last.sourceslots[lastslot] = slot;\n      }\n    }\n  }\n}\n\nfunction dispose(node) {\n  node.fn = null;\n  node.log = null;\n  cleanup(node, true);\n}\n// CONCATENATED MODULE: ./node_modules/solid-js/dist/solid.js\n\n\nfunction comparer(v, k, b, isArray, path, r) {\n  let index;\n  const newPath = path.concat([k]);\n\n  if (isArray && v != null && typeof v === 'object' && k != (index = b.findIndex(i => i && (i === v || v.id != null && i.id === v.id || v._id != null && i._id === v._id)))) {\n    return r.push(newPath.concat([index > -1 ? b[index] : v]));\n  }\n\n  return r.push.apply(r, diff(v, b[k], newPath));\n}\n\nfunction clone(v) {\n  if (!isObject(v)) return v;\n  if (Array.isArray(v)) return v.slice(0);\n  return Object.assign({}, v);\n}\n\nfunction isObject(obj) {\n  let ref;\n  return obj !== null && ((ref = typeof obj) === 'object' || ref === 'function');\n}\n\nfunction diff(a, b, path = []) {\n  let i, k, l, len, v;\n  const r = [];\n\n  if (!isObject(a) || b == null) {\n    if (a !== b) {\n      r.push(path.concat([a]));\n    }\n  } else if (Array.isArray(a)) {\n    for (k = i = 0, len = a.length; i < len; k = ++i) {\n      v = a[k];\n      if ((b != null ? b[k] : void 0) !== v) comparer(v, k, b, true, path, r);\n    }\n\n    if ((b != null ? b.length : void 0) > a.length) {\n      l = a.length;\n\n      while (l < b.length) {\n        r.push(path.concat([l, void 0]));\n        l++;\n      }\n    }\n  } else {\n    for (k in a) {\n      v = a[k];\n      if ((b != null ? b[k] : void 0) !== v) comparer(v, k, b, false, path, r);\n    }\n\n    for (k in b) {\n      v = b[k];\n      if (!(k in a)) r.push(path.concat([k, void 0]));\n    }\n  }\n\n  return r;\n}\n\nfunction unwrap(item) {\n  let result, unwrapped, v;\n  if (result = item != null ? item._state : void 0) return result;\n  if (!isObject(item) || typeof item === 'function' || item instanceof Element) return item;\n  if (Object.isFrozen(item)) item = clone(item);\n\n  if (Array.isArray(item)) {\n    for (let i = 0, l = item.length; i < l; i++) {\n      v = item[i];\n      if ((unwrapped = unwrap(v)) !== v) item[i] = unwrapped;\n    }\n  } else {\n    let keys = Object.keys(item);\n\n    for (let i = 0, l = keys.length; i < l; i++) {\n      v = item[keys[i]];\n      if ((unwrapped = unwrap(v)) !== v) item[keys[i]] = unwrapped;\n    }\n  }\n\n  return item;\n} // export observable\n\n\nfunction observable(input) {\n  if (Symbol.observable in input) return input[Symbol.observable]();\n  return {\n    subscribe(observer) {\n      if (!(observer instanceof Object) || observer == null) {\n        throw new TypeError('Expected the observer to be an object.');\n      }\n\n      observer = observer.next || observer;\n      let complete = false;\n      S.on(input, function next() {\n        if (complete) return;\n        observer(input());\n      });\n      return {\n        unsubscribe() {\n          complete = true;\n        }\n\n      };\n    },\n\n    [Symbol.observable]() {\n      return this;\n    }\n\n  };\n}\n\nconst SNODE = Symbol('solid-node'),\n      SPROXY = Symbol('solid-proxy');\nconst proxyTraps = {\n  get(target, property) {\n    if (property === '_state') return target;\n    const value = target[property];\n    if (es_S.isListening() && typeof value !== 'function') track(target, property, value);\n    return !isObject(value) || typeof value === 'function' || value instanceof Element ? value : wrap(value);\n  },\n\n  set() {\n    return true;\n  },\n\n  deleteProperty() {\n    return true;\n  }\n\n};\n\nfunction wrap(value) {\n  return value[SPROXY] || (value[SPROXY] = new Proxy(value, proxyTraps));\n}\n\nfunction getDataNode(target) {\n  let node = target[SNODE];\n  if (!node) target[SNODE] = node = {};\n  return node;\n}\n\nfunction track(target, property, value) {\n  let node;\n\n  if (isObject(value) && !(value instanceof Element)) {\n    if (node = getDataNode(value)) {\n      if (!node._self) node._self = es_S.makeDataNode();\n\n      node._self.current();\n    }\n  }\n\n  node = getDataNode(target);\n  node[property] || (node[property] = es_S.makeDataNode());\n  node[property].current();\n}\n\nfunction trigger(node, property, notify) {\n  if (node[property]) node[property].next();\n  if (notify && node._self) node._self.next();\n}\n\nfunction setProperty(state, property, value) {\n  value = unwrap(value);\n  if (state[property] === value) return;\n  const notify = Array.isArray(state) || !(property in state);\n\n  if (value === void 0) {\n    delete state[property];\n    if (Array.isArray(state)) state.length -= 1;\n  } else state[property] = value;\n\n  trigger(getDataNode(state), property, notify);\n}\n\nfunction mergeState(state, value) {\n  const keys = Object.keys(value) || [];\n\n  for (let i = 0; i < keys.length; i += 1) {\n    const key = keys[i];\n    setProperty(state, key, value[key]);\n  }\n}\n\nfunction updatePath(current, path, traversed = []) {\n  if (path.length === 1) {\n    let value = path[0];\n\n    if (typeof value === 'function') {\n      value = value(wrap(current), traversed); // deep map\n\n      if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i += 1) updatePath(current, value[i], traversed);\n\n        return;\n      }\n    }\n\n    return mergeState(current, value);\n  }\n\n  const part = path.shift(),\n        partType = typeof part,\n        isArray = Array.isArray(current);\n\n  if (Array.isArray(part)) {\n    // Ex. update('data', [2, 23], 'label', l => l + ' !!!');\n    for (let i = 0; i < part.length; i++) updatePath(current, [part[i]].concat(path), [].concat(traversed, [part[i]]));\n  } else if (isArray && partType === 'function') {\n    // Ex. update('data', i => i.id === 42, 'label', l => l + ' !!!');\n    for (let i = 0; i < current.length; i++) if (part(current[i], i)) updatePath(current[i], path.slice(0), [].concat(traversed, [i]));\n  } else if (isArray && partType === 'object') {\n    // Ex. update('data', { from: 3, to: 12, by: 2 }, 'label', l => l + ' !!!');\n    const {\n      from = 0,\n      to = current.length - 1,\n      by = 1\n    } = part;\n\n    for (let i = from; i <= to; i += by) updatePath(current[i], path.slice(0), [].concat(traversed, [i]));\n  } else if (isArray && part === '*') {\n    // Ex. update('data', '*', 'label', l => l + ' !!!');\n    for (let i = 0; i < current.length; i++) updatePath(current, [i].concat(path), [].concat(traversed, [i]));\n  } else if (path.length === 1) {\n    let value = path[0];\n    if (typeof value === 'function') value = value(typeof current[part] === 'object' ? wrap(current[part]) : current[part], traversed.concat([part]));\n    if (current[part] != null && typeof current[part] === 'object' && value !== null && typeof value === 'object' && !Array.isArray(value)) return mergeState(current[part], value);\n    return setProperty(current, part, value);\n  } else updatePath(current[part], path);\n}\n\nfunction useState(state) {\n  state = unwrap(state);\n  const wrappedState = wrap(state);\n  return [wrappedState, setState];\n\n  function setState() {\n    const args = arguments;\n    es_S.freeze(() => {\n      if (Array.isArray(args[0])) {\n        for (let i = 0; i < args.length; i += 1) updatePath(state, args[i]);\n      } else updatePath(state, Array.prototype.slice.call(args));\n    });\n  }\n}\n\nfunction reconcile() {\n  const path = Array.prototype.slice.call(arguments, 0, -1),\n        value = arguments[arguments.length - 1];\n  return state => {\n    state = unwrap(state);\n\n    for (let i = 0; i < path.length; i += 1) state = state[path[i]];\n\n    return diff(value, state, path);\n  };\n}\n\nfunction useMemo(fn, seed) {\n  return es_S(fn, seed);\n}\n\nfunction useSignal(value) {\n  return es_S.data(value);\n}\n\nfunction useEffect(fn, deps, defer) {\n  if (!deps) return es_S.effect(fn);\n  es_S.on(deps, fn, undefined, defer);\n}\n\nconst {\n  root,\n  cleanup: useCleanup,\n  sample,\n  freeze\n} = es_S;\n\n// CONCATENATED MODULE: ./node_modules/babel-plugin-jsx-dom-expressions/dist/createRuntime.js\nconst GROUPING = '__recGroup',\n      FORWARD = 'nextSibling',\n      BACKWARD = 'previousSibling';\n\nfunction step(node, direction) {\n  const key = node[GROUPING];\n\n  if (key) {\n    while (node[direction] && node[direction][GROUPING] === key) node = node[direction];\n  }\n\n  return node[direction];\n} // This is almost straightforward implementation of reconcillation algorithm\n// based on ivi documentation:\n// https://github.com/localvoid/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1366\n// With some fast paths from Surplus implementation:\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L86\n// And working with data directly from Stage0:\n// https://github.com/Freak613/stage0/blob/master/reconcile.js\n// This implementation is tailored for fine grained change detection and adds suupport for fragments\n\n\nfunction createRuntime_reconcile(parent, accessor, mapFn, afterRenderFn, options, beforeNode, afterNode) {\n  const {\n    wrap,\n    cleanup,\n    root,\n    sample\n  } = options;\n  let disposables = [],\n      counter = 0;\n\n  function prepNodes(node) {\n    if (node.nodeType === 11) {\n      let mark = node.firstChild;\n      counter++;\n\n      while (mark) {\n        mark[GROUPING] = counter;\n        mark = mark.nextSibling;\n      }\n    }\n\n    return node;\n  }\n\n  function createFn(item, i) {\n    return root(disposer => (disposables[i] = disposer, prepNodes(mapFn(item, i))));\n  }\n\n  function afterRender() {\n    afterRenderFn && afterRenderFn(beforeNode ? beforeNode.nextSibling : parent.firstChild, afterNode);\n  }\n\n  cleanup(function dispose() {\n    for (let i = 0; i < disposables.length; i++) disposables[i]();\n  });\n  wrap((renderedValues = []) => {\n    const data = accessor();\n    parent = beforeNode && beforeNode.parentNode || parent;\n    return sample(() => {\n      // Fast path for clear\n      const length = data.length;\n\n      if (length === 0) {\n        if (beforeNode !== undefined || afterNode !== undefined) {\n          let node = beforeNode !== undefined ? beforeNode.nextSibling : parent.firstChild,\n              newAfterNode = afterNode,\n              tmp;\n          if (newAfterNode === undefined) newAfterNode = null;\n\n          while (node !== newAfterNode) {\n            tmp = node.nextSibling;\n            parent.removeChild(node);\n            node = tmp;\n          }\n        } else parent.textContent = \"\";\n\n        for (let i = 0; i < renderedValues.length; i++) disposables[i]();\n\n        disposables = [];\n        afterRender();\n        return [];\n      } // Fast path for create\n\n\n      if (renderedValues.length === 0) {\n        let node,\n            mode = afterNode !== undefined,\n            nextData = new Array(length);\n\n        for (let i = 0; i < length; i++) {\n          node = createFn(nextData[i] = data[i], i);\n          mode ? parent.insertBefore(node, afterNode) : parent.appendChild(node);\n        }\n\n        afterRender();\n        return nextData;\n      }\n\n      let prevStart = 0,\n          newStart = 0,\n          loop = true,\n          prevEnd = renderedValues.length - 1,\n          newEnd = length - 1,\n          a,\n          b,\n          prevStartNode = beforeNode ? beforeNode.nextSibling : parent.firstChild,\n          newStartNode = prevStartNode,\n          prevEndNode = afterNode ? afterNode.previousSibling : parent.lastChild,\n          newAfterNode = afterNode;\n\n      fixes: while (loop) {\n        loop = false;\n\n        let _node; // Skip prefix\n\n\n        a = renderedValues[prevStart], b = data[newStart];\n\n        while (a === b) {\n          disposables[newStart] = disposables[prevStart];\n          prevStart++;\n          newStart++;\n          newStartNode = prevStartNode = step(prevStartNode, FORWARD);\n          if (prevEnd < prevStart || newEnd < newStart) break fixes;\n          a = renderedValues[prevStart];\n          b = data[newStart];\n        } // Skip suffix\n\n\n        a = renderedValues[prevEnd], b = data[newEnd];\n\n        while (a === b) {\n          disposables[newEnd] = disposables[prevEnd];\n          prevEnd--;\n          newEnd--;\n          newAfterNode = prevEndNode;\n          prevEndNode = step(prevEndNode, BACKWARD);\n          if (prevEnd < prevStart || newEnd < newStart) break fixes;\n          a = renderedValues[prevEnd];\n          b = data[newEnd];\n        } // Fast path to swap backward\n\n\n        a = renderedValues[prevEnd], b = data[newStart];\n\n        while (a === b) {\n          loop = true;\n          _node = step(prevEndNode, BACKWARD);\n          let mark = _node.nextSibling;\n\n          if (newStartNode !== mark) {\n            while (mark !== prevEndNode) {\n              let tmp = mark.nextSibling;\n              parent.insertBefore(mark, newStartNode);\n              mark = tmp;\n            }\n\n            parent.insertBefore(mark, newStartNode);\n            prevEndNode = _node;\n            disposables.splice(newStart, 0, disposables.splice(prevEnd, 1)[0]);\n          }\n\n          newStart++;\n          prevEnd--;\n          if (prevEnd < prevStart || newEnd < newStart) break fixes;\n          a = renderedValues[prevEnd];\n          b = data[newStart];\n        } // Fast path to swap forward\n\n\n        a = renderedValues[prevStart], b = data[newEnd];\n\n        while (a === b) {\n          loop = true;\n          _node = step(prevStartNode, FORWARD);\n          let mark = prevStartNode,\n              tmp;\n\n          if (mark !== newAfterNode) {\n            while (mark.nextSibling !== _node) {\n              tmp = mark.nextSibling;\n              parent.insertBefore(mark, newAfterNode);\n              mark = tmp;\n            }\n\n            parent.insertBefore(mark, newAfterNode);\n            disposables.splice(newEnd, 0, disposables.splice(prevStart, 1)[0]);\n            newAfterNode = mark;\n            prevStartNode = _node;\n          }\n\n          prevStart++;\n          newEnd--;\n          if (prevEnd < prevStart || newEnd < newStart) break fixes;\n          a = renderedValues[prevStart];\n          b = data[newEnd];\n        }\n      } // Fast path for shrink\n\n\n      if (newEnd < newStart) {\n        if (prevStart <= prevEnd) {\n          let next, mark, tmp;\n\n          while (prevStart <= prevEnd) {\n            next = step(prevEndNode, BACKWARD);\n            mark = prevEndNode;\n\n            while (mark !== next) {\n              tmp = mark.previousSibling;\n              parent.removeChild(mark);\n              mark = tmp;\n            }\n\n            prevEndNode = next;\n            disposables[prevEnd]();\n            prevEnd--;\n          }\n        }\n\n        disposables.length = length;\n        afterRender();\n        return data.slice(0);\n      } // Fast path for add\n\n\n      if (prevEnd < prevStart) {\n        if (newStart <= newEnd) {\n          let node,\n              mode = newAfterNode ? 1 : 0;\n\n          while (newStart <= newEnd) {\n            node = createFn(data[newStart], newStart);\n            mode ? parent.insertBefore(node, newAfterNode) : parent.appendChild(node);\n            newStart++;\n          }\n        }\n\n        afterRender();\n        return data.slice(0);\n      } // Positions for reusing nodes from current DOM state\n\n\n      const P = new Array(newEnd + 1 - newStart);\n\n      for (let i = newStart; i <= newEnd; i++) P[i] = -1; // Index to resolve position from current to new\n\n\n      const I = new Map();\n\n      for (let i = newStart; i <= newEnd; i++) I.set(data[i], i);\n\n      let reusingNodes = 0,\n          toRemove = [];\n\n      for (let i = prevStart; i <= prevEnd; i++) {\n        if (I.has(renderedValues[i])) {\n          P[I.get(renderedValues[i])] = i;\n          reusingNodes++;\n        } else {\n          toRemove.push(i);\n        }\n      } // Fast path for full replace\n\n\n      if (reusingNodes === 0) {\n        if (prevStartNode !== parent.firstChild || prevEndNode !== parent.lastChild) {\n          let node = prevStartNode,\n              tmp,\n              mark;\n          newAfterNode = prevEndNode.nextSibling;\n\n          while (node !== newAfterNode) {\n            mark = step(node, FORWARD);\n\n            while (node !== mark) {\n              tmp = node.nextSibling;\n              parent.removeChild(node);\n              node = tmp;\n            }\n\n            disposables[prevStart]();\n            prevStart++;\n          }\n        } else {\n          while (prevStart <= prevEnd) {\n            disposables[prevStart]();\n            prevStart++;\n          }\n\n          parent.textContent = \"\";\n        }\n\n        let node,\n            mode = newAfterNode ? 1 : 0;\n\n        for (let i = newStart; i <= newEnd; i++) {\n          node = createFn(data[i], i);\n          mode ? parent.insertBefore(node, newAfterNode) : parent.appendChild(node);\n        }\n\n        afterRender();\n        return data.slice(0);\n      } // What else?\n\n\n      const longestSeq = longestPositiveIncreasingSubsequence(P, newStart); // Collect nodes to work with them\n\n      const nodes = [];\n      let tmpC = prevStartNode;\n\n      for (let i = prevStart; i <= prevEnd; i++) {\n        nodes[i] = tmpC;\n        tmpC = step(tmpC, FORWARD);\n      }\n\n      for (let i = 0; i < toRemove.length; i++) {\n        const index = toRemove[i];\n        let node = nodes[index],\n            end = step(node, FORWARD),\n            tmp;\n\n        while (node !== end) {\n          tmp = node.nextSibling;\n          parent.removeChild(node);\n          node = tmp;\n        }\n\n        disposables[index]();\n      }\n\n      const oldDisposables = disposables.slice(0);\n      let lisIdx = longestSeq.length - 1,\n          tmpD;\n\n      for (let i = newEnd; i >= newStart; i--) {\n        if (longestSeq[lisIdx] === i) {\n          newAfterNode = nodes[P[longestSeq[lisIdx]]];\n          disposables[i] = oldDisposables[P[i]];\n          lisIdx--;\n        } else {\n          if (P[i] === -1) {\n            tmpD = createFn(data[i], i);\n            parent.insertBefore(tmpD, newAfterNode);\n          } else {\n            disposables[i] = oldDisposables[P[i]];\n            tmpD = nodes[P[i]];\n            let mark = tmpD,\n                end = step(mark, FORWARD),\n                tmp;\n\n            while (mark !== end) {\n              tmp = mark.nextSibling;\n              parent.insertBefore(mark, newAfterNode);\n              mark = tmp;\n            }\n          }\n\n          newAfterNode = tmpD;\n        }\n      }\n\n      disposables.length = length;\n      afterRender();\n      return data.slice(0);\n    });\n  });\n} // Picked from\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L368\n// return an array of the indices of ns that comprise the longest increasing subsequence within ns\n\n\nfunction longestPositiveIncreasingSubsequence(ns, newStart) {\n  var seq = [],\n      is = [],\n      l = -1,\n      pre = new Array(ns.length);\n\n  for (var i = newStart, len = ns.length; i < len; i++) {\n    var n = ns[i];\n    if (n < 0) continue;\n    var j = findGreatestIndexLEQ(seq, n);\n    if (j !== -1) pre[i] = is[j];\n\n    if (j === l) {\n      l++;\n      seq[l] = n;\n      is[l] = i;\n    } else if (n < seq[j + 1]) {\n      seq[j + 1] = n;\n      is[j + 1] = i;\n    }\n  }\n\n  for (i = is[l]; l >= 0; i = pre[i], l--) {\n    seq[l] = i;\n  }\n\n  return seq;\n}\n\nfunction findGreatestIndexLEQ(seq, n) {\n  // invariant: lo is guaranteed to be index of a value <= n, hi to be >\n  // therefore, they actually start out of range: (-1, last + 1)\n  var lo = -1,\n      hi = seq.length; // fast path for simple increasing sequences\n\n  if (hi > 0 && seq[hi - 1] <= n) return hi - 1;\n\n  while (hi - lo > 1) {\n    var mid = Math.floor((lo + hi) / 2);\n\n    if (seq[mid] > n) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n\n  return lo;\n}\n\nconst Types = {\n  ATTRIBUTE: 'attribute',\n  PROPERTY: 'property'\n};\nvar Attributes = {\n  href: {\n    type: Types.ATTRIBUTE\n  },\n  style: {\n    type: Types.PROPERTY,\n    alias: 'style.cssText'\n  },\n  for: {\n    type: Types.PROPERTY,\n    alias: 'htmlFor'\n  },\n  class: {\n    type: Types.PROPERTY,\n    alias: 'className'\n  },\n  // React compat\n  spellCheck: {\n    type: Types.PROPERTY,\n    alias: 'spellcheck'\n  },\n  allowFullScreen: {\n    type: Types.PROPERTY,\n    alias: 'allowFullscreen'\n  },\n  autoCapitalize: {\n    type: Types.PROPERTY,\n    alias: 'autocapitalize'\n  },\n  autoFocus: {\n    type: Types.PROPERTY,\n    alias: 'autofocus'\n  },\n  autoPlay: {\n    type: Types.PROPERTY,\n    alias: 'autoplay'\n  }\n};\n\nfunction normalizeIncomingArray(normalized, array) {\n  for (var i = 0, len = array.length; i < len; i++) {\n    var item = array[i];\n\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false) ;else if (Array.isArray(item)) {\n      normalizeIncomingArray(normalized, item);\n    } else if (typeof item === 'string') {\n      normalized.push(item);\n    } else {\n      normalized.push(item.toString());\n    }\n  }\n\n  return normalized;\n}\n\nfunction clearAll(parent, current, marker) {\n  if (!marker) return parent.textContent = '';\n\n  if (Array.isArray(current)) {\n    for (let i = 0; i < current.length; i++) {\n      parent.removeChild(current[i]);\n    }\n  } else if (current != null && current != '') parent.removeChild(marker.previousSibling);\n\n  return '';\n}\n\nfunction model(el) {\n  let m = el.model,\n      a = el.action,\n      r;\n  if (!m && el.parentNode) r = model(el.parentNode);\n  return [m || r && r[0], a || r && r[1]];\n}\n\nfunction createRuntime(options) {\n  const {\n    wrap,\n    cleanup,\n    root\n  } = options;\n\n  function insertExpression(parent, value, current, marker) {\n    if (value === current) return current;\n    parent = marker && marker.parentNode || parent;\n    const t = typeof value;\n\n    if (t === 'string' || t === 'number') {\n      if (t === 'number') value = value.toString();\n\n      if (marker) {\n        if (current !== '' && typeof current === 'string') {\n          current = marker.previousSibling.data = value;\n        } else {\n          const node = document.createTextNode(value);\n\n          if (current !== '' && current != null) {\n            parent.replaceChild(node, marker.previousSibling);\n          } else parent.insertBefore(node, marker);\n\n          current = value;\n        }\n      } else {\n        if (current !== '' && typeof current === 'string') {\n          current = parent.firstChild.data = value;\n        } else current = parent.textContent = value;\n      }\n    } else if (value == null || value === '' || t === 'boolean') {\n      current = clearAll(parent, current, marker);\n    } else if (t === 'function') {\n      wrap(function () {\n        current = insertExpression(parent, value(), current, marker);\n      });\n    } else if (value instanceof Node) {\n      if (Array.isArray(current)) {\n        if (current.length === 0) {\n          parent.insertBefore(value, marker);\n        } else if (current.length === 1) {\n          parent.replaceChild(value, current[0]);\n        } else {\n          clearAll(parent, current, marker);\n          parent.appendChild(value);\n        }\n      } else if (current == null || current === '') {\n        parent.insertBefore(value, marker);\n      } else {\n        parent.replaceChild(value, marker && marker.previousSibling || parent.firstChild);\n      }\n\n      current = value;\n    } else if (Array.isArray(value)) {\n      let array = normalizeIncomingArray([], value);\n      clearAll(parent, current, marker);\n\n      if (array.length !== 0) {\n        for (let i = 0, len = array.length; i < len; i++) {\n          let node = array[i];\n          if (!(node instanceof Node)) node = array[i] = document.createTextNode(node);\n          parent.insertBefore(node, marker);\n        }\n      }\n\n      current = array;\n    } else {\n      throw new Error(\"content must be Node, stringable, or array of same\");\n    }\n\n    return current;\n  }\n\n  return Object.assign({\n    insert(parent, accessor, init, marker) {\n      if (typeof accessor !== 'function') return insertExpression(parent, accessor, init, marker);\n      wrap((current = init) => insertExpression(parent, accessor(), current, marker));\n    },\n\n    addEventListener(node, eventName, handler) {\n      node.addEventListener(eventName, e => {\n        if (handler.length < 2) return handler(e);\n        const a = model(e.target);\n        handler(e, a[0], a[1]);\n      });\n    },\n\n    spread(node, accessor) {\n      wrap(function () {\n        const props = accessor();\n        let info;\n\n        for (const prop in props) {\n          const value = props[prop];\n\n          if (prop === 'style') {\n            Object.assign(node.style, value);\n          } else if (prop === 'classList') {\n            for (const className in value) node.classList.toggle(className, value[className]);\n          } else if (info = Attributes[prop]) {\n            if (info.type === 'attribute') {\n              node.setAttribute(prop, value);\n            } else node[info.alias] = value;\n          } else node[prop] = value;\n        }\n      });\n    },\n\n    flow(parent, type, accessor, expr, afterRender, marker) {\n      if (type === 'each') {\n        let startNode;\n        if (marker) startNode = marker.previousSibling;\n        createRuntime_reconcile(parent, accessor, expr, afterRender, options, startNode, marker);\n      } else if (type === 'when') {\n        let current, disposable;\n        cleanup(function dispose() {\n          disposable && disposable();\n        });\n        wrap(cached => {\n          const value = accessor();\n          if (value === cached) return cached;\n          disposable && disposable();\n\n          if (value == null || value === false) {\n            clearAll(parent, cached, marker);\n            return value;\n          }\n\n          root(disposer => {\n            disposable = disposer;\n            current = insertExpression(parent, expr(value), current, marker);\n            afterRender && afterRender(current, marker);\n          });\n          return value;\n        });\n      }\n    }\n\n  }, options);\n}\n\n\n// CONCATENATED MODULE: ./node_modules/solid-js/dist/dom.js\n\n\n\nfunction createHandler(className) {\n  return (e, s) => e.classList.toggle(className, s);\n}\n\nfunction shallowDiff(a, b) {\n  let sa = new Set(a),\n      sb = new Set(b);\n  return [a.filter(i => !sb.has(i)), b.filter(i => !sa.has(i))];\n}\n\nconst r = createRuntime({\n  wrap: es_S.makeComputationNode,\n  root: es_S.root,\n  cleanup: es_S.cleanup,\n  sample: es_S.sample\n});\n\nfunction selectWhen(signal, handler) {\n  if (typeof handler === 'string') handler = createHandler(handler);\n  let start, end;\n  es_S.makeComputationNode(element => {\n    const model = signal();\n    if (element) handler(element, false);\n    let marker = start;\n\n    while (marker && marker !== end) {\n      if (marker.model === model) {\n        handler(marker, true);\n        return marker;\n      }\n\n      marker = marker.nextSibling;\n    }\n  });\n  return (s, e) => (start = s, end = e);\n}\n\nfunction selectEach(signal, handler) {\n  if (typeof handler === 'string') handler = createHandler(handler);\n  let start, end;\n  es_S.makeComputationNode(elements => {\n    const models = signal(),\n          newElements = [];\n    let marker = start;\n\n    while (marker && marker !== end) {\n      if (models.indexOf(marker.model) > -1) newElements.push(marker);\n      marker = marker.nextSibling;\n    }\n\n    const [additions, removals] = shallowDiff(newElements, elements);\n    additions.forEach(el => handler(el, true));\n    removals.forEach(el => handler(el, false));\n    return newElements;\n  });\n  return (s, e) => (start = s, end = e);\n}\n\n\n// CONCATENATED MODULE: ./src/App.jsx\nconst _tmpl$7 = document.createElement(\"template\");\n\n_tmpl$7.innerHTML = \"<button class='clear-completed'>Clear completed</button>\";\n\nconst _tmpl$6 = document.createElement(\"template\");\n\n_tmpl$6.innerHTML = \"<footer class='footer'><span class='todo-count'><strong></strong> left\\n    </span><ul class='filters'><li><a href='#/'>All</a></li><span></span><li><a href='#/active'>Active</a></li><span></span><li><a href='#/completed'>Completed</a></li></ul></footer>\";\n\nconst _tmpl$5 = document.createElement(\"template\");\n\n_tmpl$5.innerHTML = \"<input class='edit'/>\";\n\nconst _tmpl$4 = document.createElement(\"template\");\n\n_tmpl$4.innerHTML = \"<li class='todo'><div class='view'><input class='toggle' type='checkbox'/><label></label><button class='destroy'></button></div></li>\";\n\nconst _tmpl$3 = document.createElement(\"template\");\n\n_tmpl$3.innerHTML = \"<section class='main'><input id='toggle-all' class='toggle-all' type='checkbox'/><label for='toggle-all'></label><ul class='todo-list'></ul></section>\";\n\nconst _tmpl$2 = document.createElement(\"template\");\n\n_tmpl$2.innerHTML = \"<header class='header'><h1>todos</h1><input class='new-todo' placeholder='What needs to be done?'/></header>\";\n\nconst _tmpl$ = document.createElement(\"template\");\n\n_tmpl$.innerHTML = \"<section class='todoapp'></section>\";\n\n\nconst ESCAPE_KEY = 27,\n      ENTER_KEY = 13;\n\nconst TodoApp = props => function () {\n  const _el$ = _tmpl$.content.firstChild.cloneNode(true),\n        _el$2 = _el$.insertBefore(document.createTextNode(\"\"), _el$.firstChild),\n        _el$3 = _el$.insertBefore(document.createTextNode(\"\"), _el$2.nextSibling),\n        _el$4 = _el$.insertBefore(document.createTextNode(\"\"), _el$3.nextSibling);\n\n  r.insert(_el$, TodoHeader(props), null, _el$2);\n  r.flow(_el$, \"when\", () => props.state.todos.length > 0, () => TodoList(props), null, _el$3);\n  r.flow(_el$, \"when\", () => props.state.todos.length > 0, () => TodoFooter(props), null, _el$4);\n  return _el$;\n}();\n\nconst TodoHeader = ({\n  addTodo\n}) => function () {\n  const _el$5 = _tmpl$2.content.firstChild.cloneNode(true),\n        _el$6 = _el$5.firstChild,\n        _el$7 = _el$6.nextSibling;\n\n  r.addEventListener(_el$7, \"keyup\", ({\n    target,\n    keyCode\n  }) => {\n    let title;\n    if (!(keyCode === ENTER_KEY && (title = target.value.trim()))) return;\n    addTodo({\n      title\n    });\n    target.value = '';\n  });\n  return _el$5;\n}();\n\nconst TodoList = props => {\n  const {\n    state,\n    toggleAll\n  } = props;\n\n  function filterList(todos) {\n    if (state.showMode === 'active') return todos.filter(todo => !todo.completed);else if (state.showMode === 'completed') return todos.filter(todo => todo.completed);else return todos;\n  }\n\n  return function () {\n    const _el$8 = _tmpl$3.content.firstChild.cloneNode(true),\n          _el$9 = _el$8.firstChild,\n          _el$10 = _el$9.nextSibling,\n          _el$11 = _el$10.nextSibling;\n\n    r.addEventListener(_el$9, \"change\", ({\n      target: {\n        checked\n      }\n    }) => toggleAll(checked));\n    r.wrap(() => _el$9.checked = !state.remainingCount);\n    r.flow(_el$11, \"each\", () => filterList(state.todos), todo => TodoItem(Object.assign(props, {\n      todo: todo\n    })), null);\n    return _el$8;\n  }();\n};\n\nconst TodoItem = ({\n  state,\n  editTodo,\n  removeTodo,\n  setCurrent,\n  todo\n}) => {\n  function onSave({\n    target: {\n      value\n    }\n  }) {\n    let title;\n    if (!(state.edittingTodoId === todo.id && (title = value.trim()))) return;\n    editTodo({\n      id: todo.id,\n      title\n    });\n    setCurrent();\n  }\n\n  return function () {\n    const _el$12 = _tmpl$4.content.firstChild.cloneNode(true),\n          _el$13 = _el$12.firstChild,\n          _el$14 = _el$13.firstChild,\n          _el$15 = _el$14.nextSibling,\n          _el$16 = _el$15.nextSibling,\n          _el$17 = _el$12.insertBefore(document.createTextNode(\"\"), _el$13.nextSibling);\n\n    r.wrap(() => {\n      let classNames = {\n        completed: todo.completed,\n        editing: todo.id === state.edittingTodoId\n      };\n      let classKeys = Object.keys(classNames);\n\n      for (let i = 0; i < classKeys.length; i++) _el$12.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n    });\n    r.addEventListener(_el$14, \"change\", ({\n      target: {\n        checked\n      }\n    }) => editTodo({\n      id: todo.id,\n      completed: checked\n    }));\n    r.wrap(() => _el$14.checked = todo.completed);\n    r.addEventListener(_el$15, \"dblclick\", () => setCurrent(todo.id));\n    r.insert(_el$15, () => todo.title);\n    r.addEventListener(_el$16, \"click\", () => removeTodo(todo.id));\n    r.insert(_el$12, () => todo.id === state.edittingTodoId && function () {\n      const _el$18 = _tmpl$5.content.firstChild.cloneNode(true);\n\n      r.addEventListener(_el$18, \"keyup\", e => {\n        if (e.keyCode === ENTER_KEY) onSave(e);else if (e.keyCode === ESCAPE_KEY) setCurrent();\n      });\n      r.addEventListener(_el$18, \"blur\", onSave);\n      _el$18.value = todo.title;\n      return _el$18;\n    }(), null, _el$17);\n    return _el$12;\n  }();\n};\n\nconst TodoFooter = ({\n  state,\n  clearCompleted\n}) => function () {\n  const _el$19 = _tmpl$6.content.firstChild.cloneNode(true),\n        _el$20 = _el$19.firstChild,\n        _el$21 = _el$20.firstChild,\n        _el$22 = _el$20.insertBefore(document.createTextNode(\"\"), _el$21.nextSibling),\n        _el$23 = _el$20.nextSibling,\n        _el$24 = _el$23.firstChild,\n        _el$25 = _el$24.firstChild,\n        _el$26 = _el$24.nextSibling,\n        _el$27 = _el$26.nextSibling,\n        _el$28 = _el$27.firstChild,\n        _el$29 = _el$27.nextSibling,\n        _el$30 = _el$29.nextSibling,\n        _el$31 = _el$30.firstChild,\n        _el$32 = _el$19.insertBefore(document.createTextNode(\"\"), _el$23.nextSibling);\n\n  r.insert(_el$21, () => state.remainingCount);\n  r.insert(_el$20, () => state.remainingCount === 1 ? ' item' : ' items', null, _el$22);\n  r.wrap(() => {\n    let classNames = {\n      selected: state.showMode === 'all'\n    };\n    let classKeys = Object.keys(classNames);\n\n    for (let i = 0; i < classKeys.length; i++) _el$25.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n  });\n  r.wrap(() => {\n    let classNames = {\n      selected: state.showMode === 'active'\n    };\n    let classKeys = Object.keys(classNames);\n\n    for (let i = 0; i < classKeys.length; i++) _el$28.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n  });\n  r.wrap(() => {\n    let classNames = {\n      selected: state.showMode === 'completed'\n    };\n    let classKeys = Object.keys(classNames);\n\n    for (let i = 0; i < classKeys.length; i++) _el$31.classList.toggle(classKeys[i], classNames[classKeys[i]]);\n  });\n  r.flow(_el$19, \"when\", () => state.completedCount > 0, () => function () {\n    const _el$33 = _tmpl$7.content.firstChild.cloneNode(true);\n\n    r.addEventListener(_el$33, \"click\", clearCompleted);\n    return _el$33;\n  }(), null, _el$32);\n  return _el$19;\n}();\n\n/* harmony default export */ var App = (TodoApp);\n// CONCATENATED MODULE: ./src/mapToProps.js\n\nconst LOCAL_STORAGE_KEY = 'todos-solid';\n\nfunction useLocal(_) {\n  // load stored todos on init\n  const stored = localStorage.getItem(LOCAL_STORAGE_KEY),\n        [state, setState] = _;\n  if (stored) setState(JSON.parse(stored)); // JSON.stringify creates deps on every iterable field\n\n  useEffect(() => {\n    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(state));\n  });\n  return _;\n}\n\n/* harmony default export */ var mapToProps = (() => {\n  const [state, setState] = useLocal(useState({\n    counter: 0,\n    edittingTodoId: null,\n    todos: []\n  })),\n        locationHandler = () => setState('showMode', location.hash.slice(2) || 'all');\n\n  useEffect(() => {\n    const completedCount = state.todos.filter(todo => todo.completed).length;\n    setState({\n      completedCount,\n      remainingCount: state.todos.length - completedCount\n    });\n  });\n  window.addEventListener('hashchange', locationHandler);\n  useCleanup(() => window.removeEventListener('hashchange', locationHandler));\n  return {\n    state,\n    addTodo: ({\n      title\n    }) => {\n      const id = state.counter + 1;\n      setState(['todos', t => [{\n        title,\n        id,\n        completed: false\n      }, ...t]], ['counter', id]);\n    },\n    removeTodo: todoId => setState('todos', t => t.filter(item => item.id !== todoId)),\n    editTodo: todo => {\n      const index = state.todos.findIndex(item => item.id === todo.id);\n      setState('todos', index, todo);\n    },\n    clearCompleted: () => setState('todos', t => t.filter(todo => !todo.completed)),\n    toggleAll: completed => setState('todos', todo => todo.completed !== completed, {\n      completed\n    }),\n    setCurrent: todoId => setState('edittingTodoId', todoId)\n  };\n});\n// CONCATENATED MODULE: ./src/index.js\n\n\n\nroot(() => document.body.appendChild(App(mapToProps())));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zLWpzL2Rpc3QvZXMvUy5qcz9kNTExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2xpZC1qcy9kaXN0L3NvbGlkLmpzPzg0YjQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXBsdWdpbi1qc3gtZG9tLWV4cHJlc3Npb25zL2Rpc3QvY3JlYXRlUnVudGltZS5qcz82ZWI3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zb2xpZC1qcy9kaXN0L2RvbS5qcz9mYjZiIiwid2VicGFjazovLy8uL3NyYy9BcHAuanN4P2NiYmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hcFRvUHJvcHMuanM/NjI4NiIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YmY0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBQdWJsaWMgaW50ZXJmYWNlXG52YXIgUyA9IGZ1bmN0aW9uIFMoZm4sIHZhbHVlKSB7XG4gIHZhciBub2RlID0gbmV3IENvbXB1dGF0aW9uTm9kZShmbiwgdmFsdWUpO1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0YXRpb24oKSB7XG4gICAgcmV0dXJuIG5vZGUuY3VycmVudCgpO1xuICB9O1xufTsgLy8gY29tcGF0aWJpbGl0eSB3aXRoIGNvbW1vbmpzIHN5c3RlbXMgdGhhdCBleHBlY3QgZGVmYXVsdCBleHBvcnQgdG8gYmUgYXQgcmVxdWlyZSgncy5qcycpLmRlZmF1bHQgcmF0aGVyIHRoYW4ganVzdCByZXF1aXJlKCdzLWpzJylcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUywgJ2RlZmF1bHQnLCB7XG4gIHZhbHVlOiBTXG59KTtcbmV4cG9ydCBkZWZhdWx0IFM7XG5cblMucm9vdCA9IGZ1bmN0aW9uIHJvb3QoZm4pIHtcbiAgdmFyIG93bmVyID0gT3duZXIsXG4gICAgICByb290ID0gZm4ubGVuZ3RoID09PSAwID8gVU5PV05FRCA6IG5ldyBDb21wdXRhdGlvbk5vZGUobnVsbCwgbnVsbCksXG4gICAgICByZXN1bHQgPSB1bmRlZmluZWQsXG4gICAgICBkaXNwb3NlciA9IGZuLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBmdW5jdGlvbiBfZGlzcG9zZSgpIHtcbiAgICBpZiAoUnVubmluZ0Nsb2NrICE9PSBudWxsKSB7XG4gICAgICBSb290Q2xvY2suZGlzcG9zZXMuYWRkKHJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXNwb3NlKHJvb3QpO1xuICAgIH1cbiAgfTtcbiAgT3duZXIgPSByb290O1xuXG4gIGlmIChSdW5uaW5nQ2xvY2sgPT09IG51bGwpIHtcbiAgICByZXN1bHQgPSB0b3BMZXZlbFJvb3QoZm4sIGRpc3Bvc2VyLCBvd25lcik7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZGlzcG9zZXIgPT09IG51bGwgPyBmbigpIDogZm4oZGlzcG9zZXIpO1xuICAgIE93bmVyID0gb3duZXI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZnVuY3Rpb24gdG9wTGV2ZWxSb290KGZuLCBkaXNwb3Nlciwgb3duZXIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGlzcG9zZXIgPT09IG51bGwgPyBmbigpIDogZm4oZGlzcG9zZXIpO1xuICB9IGZpbmFsbHkge1xuICAgIE93bmVyID0gb3duZXI7XG4gIH1cbn1cblxuUy5vbiA9IGZ1bmN0aW9uIG9uKGV2LCBmbiwgc2VlZCwgb25jaGFuZ2VzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV2KSkgZXYgPSBjYWxsQWxsKGV2KTtcbiAgb25jaGFuZ2VzID0gISFvbmNoYW5nZXM7XG4gIHJldHVybiBTKG9uLCBzZWVkKTtcblxuICBmdW5jdGlvbiBvbih2YWx1ZSkge1xuICAgIHZhciBydW5uaW5nID0gUnVubmluZ05vZGU7XG4gICAgZXYoKTtcbiAgICBpZiAob25jaGFuZ2VzKSBvbmNoYW5nZXMgPSBmYWxzZTtlbHNlIHtcbiAgICAgIFJ1bm5pbmdOb2RlID0gbnVsbDtcbiAgICAgIHZhbHVlID0gZm4odmFsdWUpO1xuICAgICAgUnVubmluZ05vZGUgPSBydW5uaW5nO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNhbGxBbGwoc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGFsbCgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNzLmxlbmd0aDsgaSsrKSBzc1tpXSgpO1xuICB9O1xufVxuXG5TLmVmZmVjdCA9IGZ1bmN0aW9uIGVmZmVjdChmbiwgdmFsdWUpIHtcbiAgbmV3IENvbXB1dGF0aW9uTm9kZShmbiwgdmFsdWUpO1xufTtcblxuUy5kYXRhID0gZnVuY3Rpb24gZGF0YSh2YWx1ZSkge1xuICB2YXIgbm9kZSA9IG5ldyBEYXRhTm9kZSh2YWx1ZSk7XG4gIHJldHVybiBmdW5jdGlvbiBkYXRhKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBub2RlLmN1cnJlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9O1xufTtcblxuUy52YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKGN1cnJlbnQsIGVxKSB7XG4gIHZhciBkYXRhID0gUy5kYXRhKGN1cnJlbnQpLFxuICAgICAgYWdlID0gLTE7XG4gIHJldHVybiBmdW5jdGlvbiB2YWx1ZSh1cGRhdGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGRhdGEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHNhbWUgPSBlcSA/IGVxKGN1cnJlbnQsIHVwZGF0ZSkgOiBjdXJyZW50ID09PSB1cGRhdGU7XG5cbiAgICAgIGlmICghc2FtZSkge1xuICAgICAgICB2YXIgdGltZSA9IFJvb3RDbG9jay50aW1lO1xuICAgICAgICBpZiAoYWdlID09PSB0aW1lKSB0aHJvdyBuZXcgRXJyb3IoXCJjb25mbGljdGluZyB2YWx1ZXM6IFwiICsgdXBkYXRlICsgXCIgaXMgbm90IHRoZSBzYW1lIGFzIFwiICsgY3VycmVudCk7XG4gICAgICAgIGFnZSA9IHRpbWU7XG4gICAgICAgIGN1cnJlbnQgPSB1cGRhdGU7XG4gICAgICAgIGRhdGEodXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZTtcbiAgICB9XG4gIH07XG59O1xuXG5TLmZyZWV6ZSA9IGZ1bmN0aW9uIGZyZWV6ZShmbikge1xuICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xuXG4gIGlmIChSdW5uaW5nQ2xvY2sgIT09IG51bGwpIHtcbiAgICByZXN1bHQgPSBmbigpO1xuICB9IGVsc2Uge1xuICAgIFJ1bm5pbmdDbG9jayA9IFJvb3RDbG9jaztcbiAgICBSdW5uaW5nQ2xvY2suY2hhbmdlcy5yZXNldCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IGZuKCk7XG4gICAgICBldmVudCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSdW5uaW5nQ2xvY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5TLnNhbXBsZSA9IGZ1bmN0aW9uIHNhbXBsZShmbikge1xuICB2YXIgcmVzdWx0LFxuICAgICAgcnVubmluZyA9IFJ1bm5pbmdOb2RlO1xuXG4gIGlmIChydW5uaW5nICE9PSBudWxsKSB7XG4gICAgUnVubmluZ05vZGUgPSBudWxsO1xuICAgIHJlc3VsdCA9IGZuKCk7XG4gICAgUnVubmluZ05vZGUgPSBydW5uaW5nO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGZuKCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuUy5jbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cChmbikge1xuICBpZiAoT3duZXIgIT09IG51bGwpIHtcbiAgICBpZiAoT3duZXIuY2xlYW51cHMgPT09IG51bGwpIE93bmVyLmNsZWFudXBzID0gW2ZuXTtlbHNlIE93bmVyLmNsZWFudXBzLnB1c2goZm4pO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcImNsZWFudXBzIGNyZWF0ZWQgd2l0aG91dCBhIHJvb3Qgb3IgcGFyZW50IHdpbGwgbmV2ZXIgYmUgcnVuXCIpO1xuICB9XG59OyAvLyBleHBlcmltZW50YWwgOiBleHBvc2luZyBub2RlIGNvbnN0cnVjdG9ycyBhbmQgc29tZSBzdGF0ZVxuXG5cblMubWFrZURhdGFOb2RlID0gZnVuY3Rpb24gbWFrZURhdGFOb2RlKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgRGF0YU5vZGUodmFsdWUpO1xufTtcblxuUy5tYWtlQ29tcHV0YXRpb25Ob2RlID0gZnVuY3Rpb24gbWFrZUNvbXB1dGF0aW9uTm9kZShmbiwgc2VlZCkge1xuICByZXR1cm4gbmV3IENvbXB1dGF0aW9uTm9kZShmbiwgc2VlZCk7XG59O1xuXG5TLmlzRnJvemVuID0gZnVuY3Rpb24gaXNGcm96ZW4oKSB7XG4gIHJldHVybiBSdW5uaW5nQ2xvY2sgIT09IG51bGw7XG59O1xuXG5TLmlzTGlzdGVuaW5nID0gZnVuY3Rpb24gaXNMaXN0ZW5pbmcoKSB7XG4gIHJldHVybiBSdW5uaW5nTm9kZSAhPT0gbnVsbDtcbn07IC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uXG4vLy8gR3JhcGggY2xhc3NlcyBhbmQgb3BlcmF0aW9uc1xuXG5cbnZhciBDbG9jayA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENsb2NrKCkge1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5jaGFuZ2VzID0gbmV3IFF1ZXVlKCk7IC8vIGJhdGNoZWQgY2hhbmdlcyB0byBkYXRhIG5vZGVzXG5cbiAgICB0aGlzLnVwZGF0ZXMgPSBuZXcgUXVldWUoKTsgLy8gY29tcHV0YXRpb25zIHRvIHVwZGF0ZVxuXG4gICAgdGhpcy5kaXNwb3NlcyA9IG5ldyBRdWV1ZSgpOyAvLyBkaXNwb3NhbHMgdG8gcnVuIGFmdGVyIGN1cnJlbnQgYmF0Y2ggb2YgdXBkYXRlcyBmaW5pc2hlc1xuICB9XG5cbiAgcmV0dXJuIENsb2NrO1xufSgpO1xuXG52YXIgUm9vdENsb2NrUHJveHkgPSB7XG4gIHRpbWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUm9vdENsb2NrLnRpbWU7XG4gIH1cbn07XG5cbnZhciBEYXRhTm9kZSA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERhdGFOb2RlKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucGVuZGluZyA9IE5PVFBFTkRJTkc7XG4gICAgdGhpcy5sb2cgPSBudWxsO1xuICB9XG5cbiAgRGF0YU5vZGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJ1bm5pbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICBsb2dEYXRhUmVhZCh0aGlzLCBSdW5uaW5nTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgRGF0YU5vZGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoUnVubmluZ0Nsb2NrICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5wZW5kaW5nICE9PSBOT1RQRU5ESU5HKSB7XG4gICAgICAgIC8vIHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gc2V0IG9uY2UsIGNoZWNrIGZvciBjb25mbGljdHNcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnBlbmRpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25mbGljdGluZyBjaGFuZ2VzOiBcIiArIHZhbHVlICsgXCIgIT09IFwiICsgdGhpcy5wZW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgY2hhbmdlc1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSB2YWx1ZTtcbiAgICAgICAgUm9vdENsb2NrLmNoYW5nZXMuYWRkKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3QgYmF0Y2hpbmcsIHJlc3BvbmQgdG8gY2hhbmdlIG5vd1xuICAgICAgaWYgKHRoaXMubG9nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IHZhbHVlO1xuICAgICAgICBSb290Q2xvY2suY2hhbmdlcy5hZGQodGhpcyk7XG4gICAgICAgIGV2ZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIERhdGFOb2RlLnByb3RvdHlwZS5jbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUm9vdENsb2NrUHJveHk7XG4gIH07XG5cbiAgcmV0dXJuIERhdGFOb2RlO1xufSgpO1xuXG52YXIgQ29tcHV0YXRpb25Ob2RlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29tcHV0YXRpb25Ob2RlKGZuLCB2YWx1ZSkge1xuICAgIHRoaXMuc3RhdGUgPSBDVVJSRU5UO1xuICAgIHRoaXMuc291cmNlMSA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2Uxc2xvdCA9IDA7XG4gICAgdGhpcy5zb3VyY2VzID0gbnVsbDtcbiAgICB0aGlzLnNvdXJjZXNsb3RzID0gbnVsbDtcbiAgICB0aGlzLmxvZyA9IG51bGw7XG4gICAgdGhpcy5vd25lZCA9IG51bGw7XG4gICAgdGhpcy5jbGVhbnVwcyA9IG51bGw7XG4gICAgdGhpcy5mbiA9IGZuO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmFnZSA9IFJvb3RDbG9jay50aW1lO1xuICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBvd25lciA9IE93bmVyLFxuICAgICAgICBydW5uaW5nID0gUnVubmluZ05vZGU7XG4gICAgaWYgKG93bmVyID09PSBudWxsKSBjb25zb2xlLndhcm4oXCJjb21wdXRhdGlvbnMgY3JlYXRlZCB3aXRob3V0IGEgcm9vdCBvciBwYXJlbnQgd2lsbCBuZXZlciBiZSBkaXNwb3NlZFwiKTtcbiAgICBPd25lciA9IFJ1bm5pbmdOb2RlID0gdGhpcztcblxuICAgIGlmIChSdW5uaW5nQ2xvY2sgPT09IG51bGwpIHtcbiAgICAgIHRvcGxldmVsQ29tcHV0YXRpb24odGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmZuKHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChvd25lciAmJiBvd25lciAhPT0gVU5PV05FRCkge1xuICAgICAgaWYgKG93bmVyLm93bmVkID09PSBudWxsKSBvd25lci5vd25lZCA9IFt0aGlzXTtlbHNlIG93bmVyLm93bmVkLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgT3duZXIgPSBvd25lcjtcbiAgICBSdW5uaW5nTm9kZSA9IHJ1bm5pbmc7XG4gIH1cblxuICBDb21wdXRhdGlvbk5vZGUucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJ1bm5pbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5hZ2UgPT09IFJvb3RDbG9jay50aW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBSVU5OSU5HKSB0aHJvdyBuZXcgRXJyb3IoXCJjaXJjdWxhciBkZXBlbmRlbmN5XCIpO2Vsc2UgdXBkYXRlTm9kZSh0aGlzKTsgLy8gY2hlY2tzIGZvciBzdGF0ZSA9PT0gU1RBTEUgaW50ZXJuYWxseSwgc28gZG9uJ3QgbmVlZCB0byBjaGVjayBoZXJlXG4gICAgICB9XG5cbiAgICAgIGxvZ0NvbXB1dGF0aW9uUmVhZCh0aGlzLCBSdW5uaW5nTm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgQ29tcHV0YXRpb25Ob2RlLnByb3RvdHlwZS5jbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUm9vdENsb2NrUHJveHk7XG4gIH07XG5cbiAgcmV0dXJuIENvbXB1dGF0aW9uTm9kZTtcbn0oKTtcblxudmFyIExvZyA9XG4vKiogQGNsYXNzICovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExvZygpIHtcbiAgICB0aGlzLm5vZGUxID0gbnVsbDtcbiAgICB0aGlzLm5vZGUxc2xvdCA9IDA7XG4gICAgdGhpcy5ub2RlcyA9IG51bGw7XG4gICAgdGhpcy5ub2Rlc2xvdHMgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIExvZztcbn0oKTtcblxudmFyIFF1ZXVlID1cbi8qKiBAY2xhc3MgKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9XG5cbiAgUXVldWUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY291bnQgPSAwO1xuICB9O1xuXG4gIFF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIHRoaXMuaXRlbXNbdGhpcy5jb3VudCsrXSA9IGl0ZW07XG4gIH07XG5cbiAgUXVldWUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xuICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY291bnQ7IGkrKykge1xuICAgICAgZm4oaXRlbXNbaV0pO1xuICAgICAgaXRlbXNbaV0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuY291bnQgPSAwO1xuICB9O1xuXG4gIHJldHVybiBRdWV1ZTtcbn0oKTsgLy8gQ29uc3RhbnRzXG5cblxudmFyIE5PVFBFTkRJTkcgPSB7fSxcbiAgICBDVVJSRU5UID0gMCxcbiAgICBTVEFMRSA9IDEsXG4gICAgUlVOTklORyA9IDI7IC8vIFwiR2xvYmFsc1wiIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IHN5c3RlbSBzdGF0ZVxuXG52YXIgUm9vdENsb2NrID0gbmV3IENsb2NrKCksXG4gICAgUnVubmluZ0Nsb2NrID0gbnVsbCxcbiAgICAvLyBjdXJyZW50bHkgcnVubmluZyBjbG9jayBcblJ1bm5pbmdOb2RlID0gbnVsbCxcbiAgICAvLyBjdXJyZW50bHkgcnVubmluZyBjb21wdXRhdGlvblxuT3duZXIgPSBudWxsLFxuICAgIC8vIG93bmVyIGZvciBuZXcgY29tcHV0YXRpb25zXG5VTk9XTkVEID0gbmV3IENvbXB1dGF0aW9uTm9kZShudWxsLCBudWxsKTsgLy8gRnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGxvZ1JlYWQoZnJvbSwgdG8pIHtcbiAgdmFyIGZyb21zbG90LFxuICAgICAgdG9zbG90ID0gdG8uc291cmNlMSA9PT0gbnVsbCA/IC0xIDogdG8uc291cmNlcyA9PT0gbnVsbCA/IDAgOiB0by5zb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoZnJvbS5ub2RlMSA9PT0gbnVsbCkge1xuICAgIGZyb20ubm9kZTEgPSB0bztcbiAgICBmcm9tLm5vZGUxc2xvdCA9IHRvc2xvdDtcbiAgICBmcm9tc2xvdCA9IC0xO1xuICB9IGVsc2UgaWYgKGZyb20ubm9kZXMgPT09IG51bGwpIHtcbiAgICBmcm9tLm5vZGVzID0gW3RvXTtcbiAgICBmcm9tLm5vZGVzbG90cyA9IFt0b3Nsb3RdO1xuICAgIGZyb21zbG90ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBmcm9tc2xvdCA9IGZyb20ubm9kZXMubGVuZ3RoO1xuICAgIGZyb20ubm9kZXMucHVzaCh0byk7XG4gICAgZnJvbS5ub2Rlc2xvdHMucHVzaCh0b3Nsb3QpO1xuICB9XG5cbiAgaWYgKHRvLnNvdXJjZTEgPT09IG51bGwpIHtcbiAgICB0by5zb3VyY2UxID0gZnJvbTtcbiAgICB0by5zb3VyY2Uxc2xvdCA9IGZyb21zbG90O1xuICB9IGVsc2UgaWYgKHRvLnNvdXJjZXMgPT09IG51bGwpIHtcbiAgICB0by5zb3VyY2VzID0gW2Zyb21dO1xuICAgIHRvLnNvdXJjZXNsb3RzID0gW2Zyb21zbG90XTtcbiAgfSBlbHNlIHtcbiAgICB0by5zb3VyY2VzLnB1c2goZnJvbSk7XG4gICAgdG8uc291cmNlc2xvdHMucHVzaChmcm9tc2xvdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9nRGF0YVJlYWQoZGF0YSwgdG8pIHtcbiAgaWYgKGRhdGEubG9nID09PSBudWxsKSBkYXRhLmxvZyA9IG5ldyBMb2coKTtcbiAgbG9nUmVhZChkYXRhLmxvZywgdG8pO1xufVxuXG5mdW5jdGlvbiBsb2dDb21wdXRhdGlvblJlYWQobm9kZSwgdG8pIHtcbiAgaWYgKG5vZGUubG9nID09PSBudWxsKSBub2RlLmxvZyA9IG5ldyBMb2coKTtcbiAgbG9nUmVhZChub2RlLmxvZywgdG8pO1xufVxuXG5mdW5jdGlvbiBldmVudCgpIHtcbiAgLy8gYi9jIHdlIG1pZ2h0IGJlIHVuZGVyIGEgdG9wIGxldmVsIFMucm9vdCgpLCBoYXZlIHRvIHByZXNlcnZlIGN1cnJlbnQgcm9vdFxuICB2YXIgb3duZXIgPSBPd25lcjtcbiAgUm9vdENsb2NrLnVwZGF0ZXMucmVzZXQoKTtcbiAgUm9vdENsb2NrLnRpbWUrKztcblxuICB0cnkge1xuICAgIHJ1bihSb290Q2xvY2spO1xuICB9IGZpbmFsbHkge1xuICAgIFJ1bm5pbmdDbG9jayA9IFJ1bm5pbmdOb2RlID0gbnVsbDtcbiAgICBPd25lciA9IG93bmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvcGxldmVsQ29tcHV0YXRpb24obm9kZSkge1xuICBSdW5uaW5nQ2xvY2sgPSBSb290Q2xvY2s7XG4gIFJvb3RDbG9jay5jaGFuZ2VzLnJlc2V0KCk7XG4gIFJvb3RDbG9jay51cGRhdGVzLnJlc2V0KCk7XG5cbiAgdHJ5IHtcbiAgICBub2RlLnZhbHVlID0gbm9kZS5mbihub2RlLnZhbHVlKTtcblxuICAgIGlmIChSb290Q2xvY2suY2hhbmdlcy5jb3VudCA+IDAgfHwgUm9vdENsb2NrLnVwZGF0ZXMuY291bnQgPiAwKSB7XG4gICAgICBSb290Q2xvY2sudGltZSsrO1xuICAgICAgcnVuKFJvb3RDbG9jayk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIFJ1bm5pbmdDbG9jayA9IE93bmVyID0gUnVubmluZ05vZGUgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bihjbG9jaykge1xuICB2YXIgcnVubmluZyA9IFJ1bm5pbmdDbG9jayxcbiAgICAgIGNvdW50ID0gMDtcbiAgUnVubmluZ0Nsb2NrID0gY2xvY2s7XG4gIGNsb2NrLmRpc3Bvc2VzLnJlc2V0KCk7IC8vIGZvciBlYWNoIGJhdGNoIC4uLlxuXG4gIHdoaWxlIChjbG9jay5jaGFuZ2VzLmNvdW50ICE9PSAwIHx8IGNsb2NrLnVwZGF0ZXMuY291bnQgIT09IDAgfHwgY2xvY2suZGlzcG9zZXMuY291bnQgIT09IDApIHtcbiAgICBpZiAoY291bnQgPiAwKSAvLyBkb24ndCB0aWNrIG9uIGZpcnN0IHJ1biwgb3IgZWxzZSB3ZSBleHBpcmUgYWxyZWFkeSBzY2hlZHVsZWQgdXBkYXRlc1xuICAgICAgY2xvY2sudGltZSsrO1xuICAgIGNsb2NrLmNoYW5nZXMucnVuKGFwcGx5RGF0YUNoYW5nZSk7XG4gICAgY2xvY2sudXBkYXRlcy5ydW4odXBkYXRlTm9kZSk7XG4gICAgY2xvY2suZGlzcG9zZXMucnVuKGRpc3Bvc2UpOyAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgY2hhbmdlcyBhZnRlciBleGNlc3NpdmUgYmF0Y2hlcywgYXNzdW1lIHJ1bmF3YXkgICAgICAgICAgICBcblxuICAgIGlmIChjb3VudCsrID4gMWU1KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdW5hd2F5IGNsb2NrIGRldGVjdGVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIFJ1bm5pbmdDbG9jayA9IHJ1bm5pbmc7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGF0YUNoYW5nZShkYXRhKSB7XG4gIGRhdGEudmFsdWUgPSBkYXRhLnBlbmRpbmc7XG4gIGRhdGEucGVuZGluZyA9IE5PVFBFTkRJTkc7XG4gIGlmIChkYXRhLmxvZykgbWFya0NvbXB1dGF0aW9uc1N0YWxlKGRhdGEubG9nKTtcbn1cblxuZnVuY3Rpb24gbWFya0NvbXB1dGF0aW9uc1N0YWxlKGxvZykge1xuICB2YXIgbm9kZTEgPSBsb2cubm9kZTEsXG4gICAgICBub2RlcyA9IGxvZy5ub2RlczsgLy8gbWFyayBhbGwgZG93bnN0cmVhbSBub2RlcyBzdGFsZSB3aGljaCBoYXZlbid0IGJlZW4gYWxyZWFkeVxuXG4gIGlmIChub2RlMSAhPT0gbnVsbCkgbWFya05vZGVTdGFsZShub2RlMSk7XG5cbiAgaWYgKG5vZGVzICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtYXJrTm9kZVN0YWxlKG5vZGVzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya05vZGVTdGFsZShub2RlKSB7XG4gIHZhciB0aW1lID0gUm9vdENsb2NrLnRpbWU7XG5cbiAgaWYgKG5vZGUuYWdlIDwgdGltZSkge1xuICAgIG5vZGUuYWdlID0gdGltZTtcbiAgICBub2RlLnN0YXRlID0gU1RBTEU7XG4gICAgUm9vdENsb2NrLnVwZGF0ZXMuYWRkKG5vZGUpO1xuICAgIGlmIChub2RlLm93bmVkICE9PSBudWxsKSBtYXJrT3duZWROb2Rlc0ZvckRpc3Bvc2FsKG5vZGUub3duZWQpO1xuICAgIGlmIChub2RlLmxvZyAhPT0gbnVsbCkgbWFya0NvbXB1dGF0aW9uc1N0YWxlKG5vZGUubG9nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrT3duZWROb2Rlc0ZvckRpc3Bvc2FsKG93bmVkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3duZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBvd25lZFtpXTtcbiAgICBjaGlsZC5hZ2UgPSBSb290Q2xvY2sudGltZTtcbiAgICBjaGlsZC5zdGF0ZSA9IENVUlJFTlQ7XG4gICAgaWYgKGNoaWxkLm93bmVkICE9PSBudWxsKSBtYXJrT3duZWROb2Rlc0ZvckRpc3Bvc2FsKGNoaWxkLm93bmVkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUuc3RhdGUgPT09IFNUQUxFKSB7XG4gICAgdmFyIG93bmVyID0gT3duZXIsXG4gICAgICAgIHJ1bm5pbmcgPSBSdW5uaW5nTm9kZTtcbiAgICBPd25lciA9IFJ1bm5pbmdOb2RlID0gbm9kZTtcbiAgICBub2RlLnN0YXRlID0gUlVOTklORztcbiAgICBjbGVhbnVwKG5vZGUsIGZhbHNlKTtcbiAgICBub2RlLnZhbHVlID0gbm9kZS5mbihub2RlLnZhbHVlKTtcbiAgICBub2RlLnN0YXRlID0gQ1VSUkVOVDtcbiAgICBPd25lciA9IG93bmVyO1xuICAgIFJ1bm5pbmdOb2RlID0gcnVubmluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbnVwKG5vZGUsIGZpbmFsKSB7XG4gIHZhciBzb3VyY2UxID0gbm9kZS5zb3VyY2UxLFxuICAgICAgc291cmNlcyA9IG5vZGUuc291cmNlcyxcbiAgICAgIHNvdXJjZXNsb3RzID0gbm9kZS5zb3VyY2VzbG90cyxcbiAgICAgIGNsZWFudXBzID0gbm9kZS5jbGVhbnVwcyxcbiAgICAgIG93bmVkID0gbm9kZS5vd25lZCxcbiAgICAgIGksXG4gICAgICBsZW47XG5cbiAgaWYgKGNsZWFudXBzICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGNsZWFudXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjbGVhbnVwc1tpXShmaW5hbCk7XG4gICAgfVxuXG4gICAgbm9kZS5jbGVhbnVwcyA9IG51bGw7XG4gIH1cblxuICBpZiAob3duZWQgIT09IG51bGwpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3duZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpc3Bvc2Uob3duZWRbaV0pO1xuICAgIH1cblxuICAgIG5vZGUub3duZWQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHNvdXJjZTEgIT09IG51bGwpIHtcbiAgICBjbGVhbnVwU291cmNlKHNvdXJjZTEsIG5vZGUuc291cmNlMXNsb3QpO1xuICAgIG5vZGUuc291cmNlMSA9IG51bGw7XG4gIH1cblxuICBpZiAoc291cmNlcyAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHNvdXJjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNsZWFudXBTb3VyY2Uoc291cmNlcy5wb3AoKSwgc291cmNlc2xvdHMucG9wKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbnVwU291cmNlKHNvdXJjZSwgc2xvdCkge1xuICB2YXIgbm9kZXMgPSBzb3VyY2Uubm9kZXMsXG4gICAgICBub2Rlc2xvdHMgPSBzb3VyY2Uubm9kZXNsb3RzLFxuICAgICAgbGFzdCxcbiAgICAgIGxhc3RzbG90O1xuXG4gIGlmIChzbG90ID09PSAtMSkge1xuICAgIHNvdXJjZS5ub2RlMSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbGFzdCA9IG5vZGVzLnBvcCgpO1xuICAgIGxhc3RzbG90ID0gbm9kZXNsb3RzLnBvcCgpO1xuXG4gICAgaWYgKHNsb3QgIT09IG5vZGVzLmxlbmd0aCkge1xuICAgICAgbm9kZXNbc2xvdF0gPSBsYXN0O1xuICAgICAgbm9kZXNsb3RzW3Nsb3RdID0gbGFzdHNsb3Q7XG5cbiAgICAgIGlmIChsYXN0c2xvdCA9PT0gLTEpIHtcbiAgICAgICAgbGFzdC5zb3VyY2Uxc2xvdCA9IHNsb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0LnNvdXJjZXNsb3RzW2xhc3RzbG90XSA9IHNsb3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3Bvc2Uobm9kZSkge1xuICBub2RlLmZuID0gbnVsbDtcbiAgbm9kZS5sb2cgPSBudWxsO1xuICBjbGVhbnVwKG5vZGUsIHRydWUpO1xufSIsImltcG9ydCBTJDEgZnJvbSAncy1qcyc7XG5cbmZ1bmN0aW9uIGNvbXBhcmVyKHYsIGssIGIsIGlzQXJyYXksIHBhdGgsIHIpIHtcbiAgbGV0IGluZGV4O1xuICBjb25zdCBuZXdQYXRoID0gcGF0aC5jb25jYXQoW2tdKTtcblxuICBpZiAoaXNBcnJheSAmJiB2ICE9IG51bGwgJiYgdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIGsgIT0gKGluZGV4ID0gYi5maW5kSW5kZXgoaSA9PiBpICYmIChpID09PSB2IHx8IHYuaWQgIT0gbnVsbCAmJiBpLmlkID09PSB2LmlkIHx8IHYuX2lkICE9IG51bGwgJiYgaS5faWQgPT09IHYuX2lkKSkpKSB7XG4gICAgcmV0dXJuIHIucHVzaChuZXdQYXRoLmNvbmNhdChbaW5kZXggPiAtMSA/IGJbaW5kZXhdIDogdl0pKTtcbiAgfVxuXG4gIHJldHVybiByLnB1c2guYXBwbHkociwgZGlmZih2LCBiW2tdLCBuZXdQYXRoKSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgaWYgKCFpc09iamVjdCh2KSkgcmV0dXJuIHY7XG4gIGlmIChBcnJheS5pc0FycmF5KHYpKSByZXR1cm4gdi5zbGljZSgwKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHYpO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgbGV0IHJlZjtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiAoKHJlZiA9IHR5cGVvZiBvYmopID09PSAnb2JqZWN0JyB8fCByZWYgPT09ICdmdW5jdGlvbicpO1xufVxuXG5mdW5jdGlvbiBkaWZmKGEsIGIsIHBhdGggPSBbXSkge1xuICBsZXQgaSwgaywgbCwgbGVuLCB2O1xuICBjb25zdCByID0gW107XG5cbiAgaWYgKCFpc09iamVjdChhKSB8fCBiID09IG51bGwpIHtcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgci5wdXNoKHBhdGguY29uY2F0KFthXSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgZm9yIChrID0gaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBrID0gKytpKSB7XG4gICAgICB2ID0gYVtrXTtcbiAgICAgIGlmICgoYiAhPSBudWxsID8gYltrXSA6IHZvaWQgMCkgIT09IHYpIGNvbXBhcmVyKHYsIGssIGIsIHRydWUsIHBhdGgsIHIpO1xuICAgIH1cblxuICAgIGlmICgoYiAhPSBudWxsID8gYi5sZW5ndGggOiB2b2lkIDApID4gYS5sZW5ndGgpIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGwgPCBiLmxlbmd0aCkge1xuICAgICAgICByLnB1c2gocGF0aC5jb25jYXQoW2wsIHZvaWQgMF0pKTtcbiAgICAgICAgbCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGsgaW4gYSkge1xuICAgICAgdiA9IGFba107XG4gICAgICBpZiAoKGIgIT0gbnVsbCA/IGJba10gOiB2b2lkIDApICE9PSB2KSBjb21wYXJlcih2LCBrLCBiLCBmYWxzZSwgcGF0aCwgcik7XG4gICAgfVxuXG4gICAgZm9yIChrIGluIGIpIHtcbiAgICAgIHYgPSBiW2tdO1xuICAgICAgaWYgKCEoayBpbiBhKSkgci5wdXNoKHBhdGguY29uY2F0KFtrLCB2b2lkIDBdKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHVud3JhcChpdGVtKSB7XG4gIGxldCByZXN1bHQsIHVud3JhcHBlZCwgdjtcbiAgaWYgKHJlc3VsdCA9IGl0ZW0gIT0gbnVsbCA/IGl0ZW0uX3N0YXRlIDogdm9pZCAwKSByZXR1cm4gcmVzdWx0O1xuICBpZiAoIWlzT2JqZWN0KGl0ZW0pIHx8IHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nIHx8IGl0ZW0gaW5zdGFuY2VvZiBFbGVtZW50KSByZXR1cm4gaXRlbTtcbiAgaWYgKE9iamVjdC5pc0Zyb3plbihpdGVtKSkgaXRlbSA9IGNsb25lKGl0ZW0pO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBpdGVtLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdiA9IGl0ZW1baV07XG4gICAgICBpZiAoKHVud3JhcHBlZCA9IHVud3JhcCh2KSkgIT09IHYpIGl0ZW1baV0gPSB1bndyYXBwZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMoaXRlbSk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2ID0gaXRlbVtrZXlzW2ldXTtcbiAgICAgIGlmICgodW53cmFwcGVkID0gdW53cmFwKHYpKSAhPT0gdikgaXRlbVtrZXlzW2ldXSA9IHVud3JhcHBlZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXRlbTtcbn0gLy8gZXhwb3J0IG9ic2VydmFibGVcblxuXG5mdW5jdGlvbiBvYnNlcnZhYmxlKGlucHV0KSB7XG4gIGlmIChTeW1ib2wub2JzZXJ2YWJsZSBpbiBpbnB1dCkgcmV0dXJuIGlucHV0W1N5bWJvbC5vYnNlcnZhYmxlXSgpO1xuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgaWYgKCEob2JzZXJ2ZXIgaW5zdGFuY2VvZiBPYmplY3QpIHx8IG9ic2VydmVyID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgIH1cblxuICAgICAgb2JzZXJ2ZXIgPSBvYnNlcnZlci5uZXh0IHx8IG9ic2VydmVyO1xuICAgICAgbGV0IGNvbXBsZXRlID0gZmFsc2U7XG4gICAgICBTLm9uKGlucHV0LCBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICBpZiAoY29tcGxldGUpIHJldHVybjtcbiAgICAgICAgb2JzZXJ2ZXIoaW5wdXQoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgIGNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBbU3ltYm9sLm9ic2VydmFibGVdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH07XG59XG5cbmNvbnN0IFNOT0RFID0gU3ltYm9sKCdzb2xpZC1ub2RlJyksXG4gICAgICBTUFJPWFkgPSBTeW1ib2woJ3NvbGlkLXByb3h5Jyk7XG5jb25zdCBwcm94eVRyYXBzID0ge1xuICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ19zdGF0ZScpIHJldHVybiB0YXJnZXQ7XG4gICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcGVydHldO1xuICAgIGlmIChTJDEuaXNMaXN0ZW5pbmcoKSAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHRyYWNrKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICByZXR1cm4gIWlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50ID8gdmFsdWUgOiB3cmFwKHZhbHVlKTtcbiAgfSxcblxuICBzZXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gd3JhcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWVbU1BST1hZXSB8fCAodmFsdWVbU1BST1hZXSA9IG5ldyBQcm94eSh2YWx1ZSwgcHJveHlUcmFwcykpO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhTm9kZSh0YXJnZXQpIHtcbiAgbGV0IG5vZGUgPSB0YXJnZXRbU05PREVdO1xuICBpZiAoIW5vZGUpIHRhcmdldFtTTk9ERV0gPSBub2RlID0ge307XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiB0cmFjayh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICBsZXQgbm9kZTtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgIGlmIChub2RlID0gZ2V0RGF0YU5vZGUodmFsdWUpKSB7XG4gICAgICBpZiAoIW5vZGUuX3NlbGYpIG5vZGUuX3NlbGYgPSBTJDEubWFrZURhdGFOb2RlKCk7XG5cbiAgICAgIG5vZGUuX3NlbGYuY3VycmVudCgpO1xuICAgIH1cbiAgfVxuXG4gIG5vZGUgPSBnZXREYXRhTm9kZSh0YXJnZXQpO1xuICBub2RlW3Byb3BlcnR5XSB8fCAobm9kZVtwcm9wZXJ0eV0gPSBTJDEubWFrZURhdGFOb2RlKCkpO1xuICBub2RlW3Byb3BlcnR5XS5jdXJyZW50KCk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIobm9kZSwgcHJvcGVydHksIG5vdGlmeSkge1xuICBpZiAobm9kZVtwcm9wZXJ0eV0pIG5vZGVbcHJvcGVydHldLm5leHQoKTtcbiAgaWYgKG5vdGlmeSAmJiBub2RlLl9zZWxmKSBub2RlLl9zZWxmLm5leHQoKTtcbn1cblxuZnVuY3Rpb24gc2V0UHJvcGVydHkoc3RhdGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICB2YWx1ZSA9IHVud3JhcCh2YWx1ZSk7XG4gIGlmIChzdGF0ZVtwcm9wZXJ0eV0gPT09IHZhbHVlKSByZXR1cm47XG4gIGNvbnN0IG5vdGlmeSA9IEFycmF5LmlzQXJyYXkoc3RhdGUpIHx8ICEocHJvcGVydHkgaW4gc3RhdGUpO1xuXG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGVsZXRlIHN0YXRlW3Byb3BlcnR5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkpIHN0YXRlLmxlbmd0aCAtPSAxO1xuICB9IGVsc2Ugc3RhdGVbcHJvcGVydHldID0gdmFsdWU7XG5cbiAgdHJpZ2dlcihnZXREYXRhTm9kZShzdGF0ZSksIHByb3BlcnR5LCBub3RpZnkpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVN0YXRlKHN0YXRlLCB2YWx1ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpIHx8IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgc2V0UHJvcGVydHkoc3RhdGUsIGtleSwgdmFsdWVba2V5XSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUGF0aChjdXJyZW50LCBwYXRoLCB0cmF2ZXJzZWQgPSBbXSkge1xuICBpZiAocGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICBsZXQgdmFsdWUgPSBwYXRoWzBdO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZSh3cmFwKGN1cnJlbnQpLCB0cmF2ZXJzZWQpOyAvLyBkZWVwIG1hcFxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkgdXBkYXRlUGF0aChjdXJyZW50LCB2YWx1ZVtpXSwgdHJhdmVyc2VkKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlU3RhdGUoY3VycmVudCwgdmFsdWUpO1xuICB9XG5cbiAgY29uc3QgcGFydCA9IHBhdGguc2hpZnQoKSxcbiAgICAgICAgcGFydFR5cGUgPSB0eXBlb2YgcGFydCxcbiAgICAgICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkocGFydCkpIHtcbiAgICAvLyBFeC4gdXBkYXRlKCdkYXRhJywgWzIsIDIzXSwgJ2xhYmVsJywgbCA9PiBsICsgJyAhISEnKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnQubGVuZ3RoOyBpKyspIHVwZGF0ZVBhdGgoY3VycmVudCwgW3BhcnRbaV1dLmNvbmNhdChwYXRoKSwgW10uY29uY2F0KHRyYXZlcnNlZCwgW3BhcnRbaV1dKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV4LiB1cGRhdGUoJ2RhdGEnLCBpID0+IGkuaWQgPT09IDQyLCAnbGFiZWwnLCBsID0+IGwgKyAnICEhIScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykgaWYgKHBhcnQoY3VycmVudFtpXSwgaSkpIHVwZGF0ZVBhdGgoY3VycmVudFtpXSwgcGF0aC5zbGljZSgwKSwgW10uY29uY2F0KHRyYXZlcnNlZCwgW2ldKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0VHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBFeC4gdXBkYXRlKCdkYXRhJywgeyBmcm9tOiAzLCB0bzogMTIsIGJ5OiAyIH0sICdsYWJlbCcsIGwgPT4gbCArICcgISEhJyk7XG4gICAgY29uc3Qge1xuICAgICAgZnJvbSA9IDAsXG4gICAgICB0byA9IGN1cnJlbnQubGVuZ3RoIC0gMSxcbiAgICAgIGJ5ID0gMVxuICAgIH0gPSBwYXJ0O1xuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPD0gdG87IGkgKz0gYnkpIHVwZGF0ZVBhdGgoY3VycmVudFtpXSwgcGF0aC5zbGljZSgwKSwgW10uY29uY2F0KHRyYXZlcnNlZCwgW2ldKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0ID09PSAnKicpIHtcbiAgICAvLyBFeC4gdXBkYXRlKCdkYXRhJywgJyonLCAnbGFiZWwnLCBsID0+IGwgKyAnICEhIScpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykgdXBkYXRlUGF0aChjdXJyZW50LCBbaV0uY29uY2F0KHBhdGgpLCBbXS5jb25jYXQodHJhdmVyc2VkLCBbaV0pKTtcbiAgfSBlbHNlIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgIGxldCB2YWx1ZSA9IHBhdGhbMF07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSB2YWx1ZSh0eXBlb2YgY3VycmVudFtwYXJ0XSA9PT0gJ29iamVjdCcgPyB3cmFwKGN1cnJlbnRbcGFydF0pIDogY3VycmVudFtwYXJ0XSwgdHJhdmVyc2VkLmNvbmNhdChbcGFydF0pKTtcbiAgICBpZiAoY3VycmVudFtwYXJ0XSAhPSBudWxsICYmIHR5cGVvZiBjdXJyZW50W3BhcnRdID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIG1lcmdlU3RhdGUoY3VycmVudFtwYXJ0XSwgdmFsdWUpO1xuICAgIHJldHVybiBzZXRQcm9wZXJ0eShjdXJyZW50LCBwYXJ0LCB2YWx1ZSk7XG4gIH0gZWxzZSB1cGRhdGVQYXRoKGN1cnJlbnRbcGFydF0sIHBhdGgpO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShzdGF0ZSkge1xuICBzdGF0ZSA9IHVud3JhcChzdGF0ZSk7XG4gIGNvbnN0IHdyYXBwZWRTdGF0ZSA9IHdyYXAoc3RhdGUpO1xuICByZXR1cm4gW3dyYXBwZWRTdGF0ZSwgc2V0U3RhdGVdO1xuXG4gIGZ1bmN0aW9uIHNldFN0YXRlKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgUyQxLmZyZWV6ZSgoKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDEpIHVwZGF0ZVBhdGgoc3RhdGUsIGFyZ3NbaV0pO1xuICAgICAgfSBlbHNlIHVwZGF0ZVBhdGgoc3RhdGUsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvbmNpbGUoKSB7XG4gIGNvbnN0IHBhdGggPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIC0xKSxcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhdGUgPT4ge1xuICAgIHN0YXRlID0gdW53cmFwKHN0YXRlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkgKz0gMSkgc3RhdGUgPSBzdGF0ZVtwYXRoW2ldXTtcblxuICAgIHJldHVybiBkaWZmKHZhbHVlLCBzdGF0ZSwgcGF0aCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8oZm4sIHNlZWQpIHtcbiAgcmV0dXJuIFMkMShmbiwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIHVzZVNpZ25hbCh2YWx1ZSkge1xuICByZXR1cm4gUyQxLmRhdGEodmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1c2VFZmZlY3QoZm4sIGRlcHMsIGRlZmVyKSB7XG4gIGlmICghZGVwcykgcmV0dXJuIFMkMS5lZmZlY3QoZm4pO1xuICBTJDEub24oZGVwcywgZm4sIHVuZGVmaW5lZCwgZGVmZXIpO1xufVxuXG5jb25zdCB7XG4gIHJvb3QsXG4gIGNsZWFudXA6IHVzZUNsZWFudXAsXG4gIHNhbXBsZSxcbiAgZnJlZXplXG59ID0gUyQxO1xuZXhwb3J0IHsgcm9vdCwgdXNlQ2xlYW51cCwgc2FtcGxlLCBmcmVlemUsIHVud3JhcCwgb2JzZXJ2YWJsZSwgdXNlU3RhdGUsIHJlY29uY2lsZSwgdXNlTWVtbywgdXNlU2lnbmFsLCB1c2VFZmZlY3QgfTsiLCJjb25zdCBHUk9VUElORyA9ICdfX3JlY0dyb3VwJyxcbiAgICAgIEZPUldBUkQgPSAnbmV4dFNpYmxpbmcnLFxuICAgICAgQkFDS1dBUkQgPSAncHJldmlvdXNTaWJsaW5nJztcblxuZnVuY3Rpb24gc3RlcChub2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qga2V5ID0gbm9kZVtHUk9VUElOR107XG5cbiAgaWYgKGtleSkge1xuICAgIHdoaWxlIChub2RlW2RpcmVjdGlvbl0gJiYgbm9kZVtkaXJlY3Rpb25dW0dST1VQSU5HXSA9PT0ga2V5KSBub2RlID0gbm9kZVtkaXJlY3Rpb25dO1xuICB9XG5cbiAgcmV0dXJuIG5vZGVbZGlyZWN0aW9uXTtcbn0gLy8gVGhpcyBpcyBhbG1vc3Qgc3RyYWlnaHRmb3J3YXJkIGltcGxlbWVudGF0aW9uIG9mIHJlY29uY2lsbGF0aW9uIGFsZ29yaXRobVxuLy8gYmFzZWQgb24gaXZpIGRvY3VtZW50YXRpb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbG9jYWx2b2lkL2l2aS9ibG9iLzJjODFlYWQ5MzRiOTEyOGUwOTJjYzJhNWVmMmQzY2FiYzczY2I1ZGQvcGFja2FnZXMvaXZpL3NyYy92ZG9tL2ltcGxlbWVudGF0aW9uLnRzI0wxMzY2XG4vLyBXaXRoIHNvbWUgZmFzdCBwYXRocyBmcm9tIFN1cnBsdXMgaW1wbGVtZW50YXRpb246XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYWRhbWhhaWxlL3N1cnBsdXMvYmxvYi9tYXN0ZXIvc3JjL3J1bnRpbWUvY29udGVudC50cyNMODZcbi8vIEFuZCB3b3JraW5nIHdpdGggZGF0YSBkaXJlY3RseSBmcm9tIFN0YWdlMDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9GcmVhazYxMy9zdGFnZTAvYmxvYi9tYXN0ZXIvcmVjb25jaWxlLmpzXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIHRhaWxvcmVkIGZvciBmaW5lIGdyYWluZWQgY2hhbmdlIGRldGVjdGlvbiBhbmQgYWRkcyBzdXVwcG9ydCBmb3IgZnJhZ21lbnRzXG5cblxuZnVuY3Rpb24gcmVjb25jaWxlKHBhcmVudCwgYWNjZXNzb3IsIG1hcEZuLCBhZnRlclJlbmRlckZuLCBvcHRpb25zLCBiZWZvcmVOb2RlLCBhZnRlck5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHdyYXAsXG4gICAgY2xlYW51cCxcbiAgICByb290LFxuICAgIHNhbXBsZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGRpc3Bvc2FibGVzID0gW10sXG4gICAgICBjb3VudGVyID0gMDtcblxuICBmdW5jdGlvbiBwcmVwTm9kZXMobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgbGV0IG1hcmsgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICBjb3VudGVyKys7XG5cbiAgICAgIHdoaWxlIChtYXJrKSB7XG4gICAgICAgIG1hcmtbR1JPVVBJTkddID0gY291bnRlcjtcbiAgICAgICAgbWFyayA9IG1hcmsubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGbihpdGVtLCBpKSB7XG4gICAgcmV0dXJuIHJvb3QoZGlzcG9zZXIgPT4gKGRpc3Bvc2FibGVzW2ldID0gZGlzcG9zZXIsIHByZXBOb2RlcyhtYXBGbihpdGVtLCBpKSkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge1xuICAgIGFmdGVyUmVuZGVyRm4gJiYgYWZ0ZXJSZW5kZXJGbihiZWZvcmVOb2RlID8gYmVmb3JlTm9kZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLCBhZnRlck5vZGUpO1xuICB9XG5cbiAgY2xlYW51cChmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlzcG9zYWJsZXMubGVuZ3RoOyBpKyspIGRpc3Bvc2FibGVzW2ldKCk7XG4gIH0pO1xuICB3cmFwKChyZW5kZXJlZFZhbHVlcyA9IFtdKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGFjY2Vzc29yKCk7XG4gICAgcGFyZW50ID0gYmVmb3JlTm9kZSAmJiBiZWZvcmVOb2RlLnBhcmVudE5vZGUgfHwgcGFyZW50O1xuICAgIHJldHVybiBzYW1wbGUoKCkgPT4ge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBjbGVhclxuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGJlZm9yZU5vZGUgIT09IHVuZGVmaW5lZCB8fCBhZnRlck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGxldCBub2RlID0gYmVmb3JlTm9kZSAhPT0gdW5kZWZpbmVkID8gYmVmb3JlTm9kZS5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgICBuZXdBZnRlck5vZGUgPSBhZnRlck5vZGUsXG4gICAgICAgICAgICAgIHRtcDtcbiAgICAgICAgICBpZiAobmV3QWZ0ZXJOb2RlID09PSB1bmRlZmluZWQpIG5ld0FmdGVyTm9kZSA9IG51bGw7XG5cbiAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbmV3QWZ0ZXJOb2RlKSB7XG4gICAgICAgICAgICB0bXAgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBwYXJlbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRWYWx1ZXMubGVuZ3RoOyBpKyspIGRpc3Bvc2FibGVzW2ldKCk7XG5cbiAgICAgICAgZGlzcG9zYWJsZXMgPSBbXTtcbiAgICAgICAgYWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSAvLyBGYXN0IHBhdGggZm9yIGNyZWF0ZVxuXG5cbiAgICAgIGlmIChyZW5kZXJlZFZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbGV0IG5vZGUsXG4gICAgICAgICAgICBtb2RlID0gYWZ0ZXJOb2RlICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBuZXh0RGF0YSA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gY3JlYXRlRm4obmV4dERhdGFbaV0gPSBkYXRhW2ldLCBpKTtcbiAgICAgICAgICBtb2RlID8gcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBhZnRlck5vZGUpIDogcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIG5leHREYXRhO1xuICAgICAgfVxuXG4gICAgICBsZXQgcHJldlN0YXJ0ID0gMCxcbiAgICAgICAgICBuZXdTdGFydCA9IDAsXG4gICAgICAgICAgbG9vcCA9IHRydWUsXG4gICAgICAgICAgcHJldkVuZCA9IHJlbmRlcmVkVmFsdWVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgbmV3RW5kID0gbGVuZ3RoIC0gMSxcbiAgICAgICAgICBhLFxuICAgICAgICAgIGIsXG4gICAgICAgICAgcHJldlN0YXJ0Tm9kZSA9IGJlZm9yZU5vZGUgPyBiZWZvcmVOb2RlLm5leHRTaWJsaW5nIDogcGFyZW50LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgbmV3U3RhcnROb2RlID0gcHJldlN0YXJ0Tm9kZSxcbiAgICAgICAgICBwcmV2RW5kTm9kZSA9IGFmdGVyTm9kZSA/IGFmdGVyTm9kZS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkLFxuICAgICAgICAgIG5ld0FmdGVyTm9kZSA9IGFmdGVyTm9kZTtcblxuICAgICAgZml4ZXM6IHdoaWxlIChsb29wKSB7XG4gICAgICAgIGxvb3AgPSBmYWxzZTtcblxuICAgICAgICBsZXQgX25vZGU7IC8vIFNraXAgcHJlZml4XG5cblxuICAgICAgICBhID0gcmVuZGVyZWRWYWx1ZXNbcHJldlN0YXJ0XSwgYiA9IGRhdGFbbmV3U3RhcnRdO1xuXG4gICAgICAgIHdoaWxlIChhID09PSBiKSB7XG4gICAgICAgICAgZGlzcG9zYWJsZXNbbmV3U3RhcnRdID0gZGlzcG9zYWJsZXNbcHJldlN0YXJ0XTtcbiAgICAgICAgICBwcmV2U3RhcnQrKztcbiAgICAgICAgICBuZXdTdGFydCsrO1xuICAgICAgICAgIG5ld1N0YXJ0Tm9kZSA9IHByZXZTdGFydE5vZGUgPSBzdGVwKHByZXZTdGFydE5vZGUsIEZPUldBUkQpO1xuICAgICAgICAgIGlmIChwcmV2RW5kIDwgcHJldlN0YXJ0IHx8IG5ld0VuZCA8IG5ld1N0YXJ0KSBicmVhayBmaXhlcztcbiAgICAgICAgICBhID0gcmVuZGVyZWRWYWx1ZXNbcHJldlN0YXJ0XTtcbiAgICAgICAgICBiID0gZGF0YVtuZXdTdGFydF07XG4gICAgICAgIH0gLy8gU2tpcCBzdWZmaXhcblxuXG4gICAgICAgIGEgPSByZW5kZXJlZFZhbHVlc1twcmV2RW5kXSwgYiA9IGRhdGFbbmV3RW5kXTtcblxuICAgICAgICB3aGlsZSAoYSA9PT0gYikge1xuICAgICAgICAgIGRpc3Bvc2FibGVzW25ld0VuZF0gPSBkaXNwb3NhYmxlc1twcmV2RW5kXTtcbiAgICAgICAgICBwcmV2RW5kLS07XG4gICAgICAgICAgbmV3RW5kLS07XG4gICAgICAgICAgbmV3QWZ0ZXJOb2RlID0gcHJldkVuZE5vZGU7XG4gICAgICAgICAgcHJldkVuZE5vZGUgPSBzdGVwKHByZXZFbmROb2RlLCBCQUNLV0FSRCk7XG4gICAgICAgICAgaWYgKHByZXZFbmQgPCBwcmV2U3RhcnQgfHwgbmV3RW5kIDwgbmV3U3RhcnQpIGJyZWFrIGZpeGVzO1xuICAgICAgICAgIGEgPSByZW5kZXJlZFZhbHVlc1twcmV2RW5kXTtcbiAgICAgICAgICBiID0gZGF0YVtuZXdFbmRdO1xuICAgICAgICB9IC8vIEZhc3QgcGF0aCB0byBzd2FwIGJhY2t3YXJkXG5cblxuICAgICAgICBhID0gcmVuZGVyZWRWYWx1ZXNbcHJldkVuZF0sIGIgPSBkYXRhW25ld1N0YXJ0XTtcblxuICAgICAgICB3aGlsZSAoYSA9PT0gYikge1xuICAgICAgICAgIGxvb3AgPSB0cnVlO1xuICAgICAgICAgIF9ub2RlID0gc3RlcChwcmV2RW5kTm9kZSwgQkFDS1dBUkQpO1xuICAgICAgICAgIGxldCBtYXJrID0gX25vZGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICBpZiAobmV3U3RhcnROb2RlICE9PSBtYXJrKSB7XG4gICAgICAgICAgICB3aGlsZSAobWFyayAhPT0gcHJldkVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgbGV0IHRtcCA9IG1hcmsubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobWFyaywgbmV3U3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgbWFyayA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShtYXJrLCBuZXdTdGFydE5vZGUpO1xuICAgICAgICAgICAgcHJldkVuZE5vZGUgPSBfbm9kZTtcbiAgICAgICAgICAgIGRpc3Bvc2FibGVzLnNwbGljZShuZXdTdGFydCwgMCwgZGlzcG9zYWJsZXMuc3BsaWNlKHByZXZFbmQsIDEpWzBdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdTdGFydCsrO1xuICAgICAgICAgIHByZXZFbmQtLTtcbiAgICAgICAgICBpZiAocHJldkVuZCA8IHByZXZTdGFydCB8fCBuZXdFbmQgPCBuZXdTdGFydCkgYnJlYWsgZml4ZXM7XG4gICAgICAgICAgYSA9IHJlbmRlcmVkVmFsdWVzW3ByZXZFbmRdO1xuICAgICAgICAgIGIgPSBkYXRhW25ld1N0YXJ0XTtcbiAgICAgICAgfSAvLyBGYXN0IHBhdGggdG8gc3dhcCBmb3J3YXJkXG5cblxuICAgICAgICBhID0gcmVuZGVyZWRWYWx1ZXNbcHJldlN0YXJ0XSwgYiA9IGRhdGFbbmV3RW5kXTtcblxuICAgICAgICB3aGlsZSAoYSA9PT0gYikge1xuICAgICAgICAgIGxvb3AgPSB0cnVlO1xuICAgICAgICAgIF9ub2RlID0gc3RlcChwcmV2U3RhcnROb2RlLCBGT1JXQVJEKTtcbiAgICAgICAgICBsZXQgbWFyayA9IHByZXZTdGFydE5vZGUsXG4gICAgICAgICAgICAgIHRtcDtcblxuICAgICAgICAgIGlmIChtYXJrICE9PSBuZXdBZnRlck5vZGUpIHtcbiAgICAgICAgICAgIHdoaWxlIChtYXJrLm5leHRTaWJsaW5nICE9PSBfbm9kZSkge1xuICAgICAgICAgICAgICB0bXAgPSBtYXJrLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG1hcmssIG5ld0FmdGVyTm9kZSk7XG4gICAgICAgICAgICAgIG1hcmsgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobWFyaywgbmV3QWZ0ZXJOb2RlKTtcbiAgICAgICAgICAgIGRpc3Bvc2FibGVzLnNwbGljZShuZXdFbmQsIDAsIGRpc3Bvc2FibGVzLnNwbGljZShwcmV2U3RhcnQsIDEpWzBdKTtcbiAgICAgICAgICAgIG5ld0FmdGVyTm9kZSA9IG1hcms7XG4gICAgICAgICAgICBwcmV2U3RhcnROb2RlID0gX25vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlN0YXJ0Kys7XG4gICAgICAgICAgbmV3RW5kLS07XG4gICAgICAgICAgaWYgKHByZXZFbmQgPCBwcmV2U3RhcnQgfHwgbmV3RW5kIDwgbmV3U3RhcnQpIGJyZWFrIGZpeGVzO1xuICAgICAgICAgIGEgPSByZW5kZXJlZFZhbHVlc1twcmV2U3RhcnRdO1xuICAgICAgICAgIGIgPSBkYXRhW25ld0VuZF07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRmFzdCBwYXRoIGZvciBzaHJpbmtcblxuXG4gICAgICBpZiAobmV3RW5kIDwgbmV3U3RhcnQpIHtcbiAgICAgICAgaWYgKHByZXZTdGFydCA8PSBwcmV2RW5kKSB7XG4gICAgICAgICAgbGV0IG5leHQsIG1hcmssIHRtcDtcblxuICAgICAgICAgIHdoaWxlIChwcmV2U3RhcnQgPD0gcHJldkVuZCkge1xuICAgICAgICAgICAgbmV4dCA9IHN0ZXAocHJldkVuZE5vZGUsIEJBQ0tXQVJEKTtcbiAgICAgICAgICAgIG1hcmsgPSBwcmV2RW5kTm9kZTtcblxuICAgICAgICAgICAgd2hpbGUgKG1hcmsgIT09IG5leHQpIHtcbiAgICAgICAgICAgICAgdG1wID0gbWFyay5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChtYXJrKTtcbiAgICAgICAgICAgICAgbWFyayA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJldkVuZE5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgZGlzcG9zYWJsZXNbcHJldkVuZF0oKTtcbiAgICAgICAgICAgIHByZXZFbmQtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwb3NhYmxlcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIGFmdGVyUmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKDApO1xuICAgICAgfSAvLyBGYXN0IHBhdGggZm9yIGFkZFxuXG5cbiAgICAgIGlmIChwcmV2RW5kIDwgcHJldlN0YXJ0KSB7XG4gICAgICAgIGlmIChuZXdTdGFydCA8PSBuZXdFbmQpIHtcbiAgICAgICAgICBsZXQgbm9kZSxcbiAgICAgICAgICAgICAgbW9kZSA9IG5ld0FmdGVyTm9kZSA/IDEgOiAwO1xuXG4gICAgICAgICAgd2hpbGUgKG5ld1N0YXJ0IDw9IG5ld0VuZCkge1xuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZUZuKGRhdGFbbmV3U3RhcnRdLCBuZXdTdGFydCk7XG4gICAgICAgICAgICBtb2RlID8gcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBuZXdBZnRlck5vZGUpIDogcGFyZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgICAgbmV3U3RhcnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlbmRlcigpO1xuICAgICAgICByZXR1cm4gZGF0YS5zbGljZSgwKTtcbiAgICAgIH0gLy8gUG9zaXRpb25zIGZvciByZXVzaW5nIG5vZGVzIGZyb20gY3VycmVudCBET00gc3RhdGVcblxuXG4gICAgICBjb25zdCBQID0gbmV3IEFycmF5KG5ld0VuZCArIDEgLSBuZXdTdGFydCk7XG5cbiAgICAgIGZvciAobGV0IGkgPSBuZXdTdGFydDsgaSA8PSBuZXdFbmQ7IGkrKykgUFtpXSA9IC0xOyAvLyBJbmRleCB0byByZXNvbHZlIHBvc2l0aW9uIGZyb20gY3VycmVudCB0byBuZXdcblxuXG4gICAgICBjb25zdCBJID0gbmV3IE1hcCgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gbmV3U3RhcnQ7IGkgPD0gbmV3RW5kOyBpKyspIEkuc2V0KGRhdGFbaV0sIGkpO1xuXG4gICAgICBsZXQgcmV1c2luZ05vZGVzID0gMCxcbiAgICAgICAgICB0b1JlbW92ZSA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gcHJldlN0YXJ0OyBpIDw9IHByZXZFbmQ7IGkrKykge1xuICAgICAgICBpZiAoSS5oYXMocmVuZGVyZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgUFtJLmdldChyZW5kZXJlZFZhbHVlc1tpXSldID0gaTtcbiAgICAgICAgICByZXVzaW5nTm9kZXMrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b1JlbW92ZS5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEZhc3QgcGF0aCBmb3IgZnVsbCByZXBsYWNlXG5cblxuICAgICAgaWYgKHJldXNpbmdOb2RlcyA9PT0gMCkge1xuICAgICAgICBpZiAocHJldlN0YXJ0Tm9kZSAhPT0gcGFyZW50LmZpcnN0Q2hpbGQgfHwgcHJldkVuZE5vZGUgIT09IHBhcmVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICBsZXQgbm9kZSA9IHByZXZTdGFydE5vZGUsXG4gICAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgICAgbWFyaztcbiAgICAgICAgICBuZXdBZnRlck5vZGUgPSBwcmV2RW5kTm9kZS5uZXh0U2libGluZztcblxuICAgICAgICAgIHdoaWxlIChub2RlICE9PSBuZXdBZnRlck5vZGUpIHtcbiAgICAgICAgICAgIG1hcmsgPSBzdGVwKG5vZGUsIEZPUldBUkQpO1xuXG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gbWFyaykge1xuICAgICAgICAgICAgICB0bXAgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgIG5vZGUgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpc3Bvc2FibGVzW3ByZXZTdGFydF0oKTtcbiAgICAgICAgICAgIHByZXZTdGFydCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAocHJldlN0YXJ0IDw9IHByZXZFbmQpIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGVzW3ByZXZTdGFydF0oKTtcbiAgICAgICAgICAgIHByZXZTdGFydCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbm9kZSxcbiAgICAgICAgICAgIG1vZGUgPSBuZXdBZnRlck5vZGUgPyAxIDogMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gbmV3U3RhcnQ7IGkgPD0gbmV3RW5kOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gY3JlYXRlRm4oZGF0YVtpXSwgaSk7XG4gICAgICAgICAgbW9kZSA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV3QWZ0ZXJOb2RlKSA6IHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFmdGVyUmVuZGVyKCk7XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKDApO1xuICAgICAgfSAvLyBXaGF0IGVsc2U/XG5cblxuICAgICAgY29uc3QgbG9uZ2VzdFNlcSA9IGxvbmdlc3RQb3NpdGl2ZUluY3JlYXNpbmdTdWJzZXF1ZW5jZShQLCBuZXdTdGFydCk7IC8vIENvbGxlY3Qgbm9kZXMgdG8gd29yayB3aXRoIHRoZW1cblxuICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgIGxldCB0bXBDID0gcHJldlN0YXJ0Tm9kZTtcblxuICAgICAgZm9yIChsZXQgaSA9IHByZXZTdGFydDsgaSA8PSBwcmV2RW5kOyBpKyspIHtcbiAgICAgICAgbm9kZXNbaV0gPSB0bXBDO1xuICAgICAgICB0bXBDID0gc3RlcCh0bXBDLCBGT1JXQVJEKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRvUmVtb3ZlW2ldO1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2luZGV4XSxcbiAgICAgICAgICAgIGVuZCA9IHN0ZXAobm9kZSwgRk9SV0FSRCksXG4gICAgICAgICAgICB0bXA7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IGVuZCkge1xuICAgICAgICAgIHRtcCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgIG5vZGUgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwb3NhYmxlc1tpbmRleF0oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkRGlzcG9zYWJsZXMgPSBkaXNwb3NhYmxlcy5zbGljZSgwKTtcbiAgICAgIGxldCBsaXNJZHggPSBsb25nZXN0U2VxLmxlbmd0aCAtIDEsXG4gICAgICAgICAgdG1wRDtcblxuICAgICAgZm9yIChsZXQgaSA9IG5ld0VuZDsgaSA+PSBuZXdTdGFydDsgaS0tKSB7XG4gICAgICAgIGlmIChsb25nZXN0U2VxW2xpc0lkeF0gPT09IGkpIHtcbiAgICAgICAgICBuZXdBZnRlck5vZGUgPSBub2Rlc1tQW2xvbmdlc3RTZXFbbGlzSWR4XV1dO1xuICAgICAgICAgIGRpc3Bvc2FibGVzW2ldID0gb2xkRGlzcG9zYWJsZXNbUFtpXV07XG4gICAgICAgICAgbGlzSWR4LS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFBbaV0gPT09IC0xKSB7XG4gICAgICAgICAgICB0bXBEID0gY3JlYXRlRm4oZGF0YVtpXSwgaSk7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRtcEQsIG5ld0FmdGVyTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3Bvc2FibGVzW2ldID0gb2xkRGlzcG9zYWJsZXNbUFtpXV07XG4gICAgICAgICAgICB0bXBEID0gbm9kZXNbUFtpXV07XG4gICAgICAgICAgICBsZXQgbWFyayA9IHRtcEQsXG4gICAgICAgICAgICAgICAgZW5kID0gc3RlcChtYXJrLCBGT1JXQVJEKSxcbiAgICAgICAgICAgICAgICB0bXA7XG5cbiAgICAgICAgICAgIHdoaWxlIChtYXJrICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgdG1wID0gbWFyay5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShtYXJrLCBuZXdBZnRlck5vZGUpO1xuICAgICAgICAgICAgICBtYXJrID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld0FmdGVyTm9kZSA9IHRtcEQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlzcG9zYWJsZXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgYWZ0ZXJSZW5kZXIoKTtcbiAgICAgIHJldHVybiBkYXRhLnNsaWNlKDApO1xuICAgIH0pO1xuICB9KTtcbn0gLy8gUGlja2VkIGZyb21cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hZGFtaGFpbGUvc3VycGx1cy9ibG9iL21hc3Rlci9zcmMvcnVudGltZS9jb250ZW50LnRzI0wzNjhcbi8vIHJldHVybiBhbiBhcnJheSBvZiB0aGUgaW5kaWNlcyBvZiBucyB0aGF0IGNvbXByaXNlIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugd2l0aGluIG5zXG5cblxuZnVuY3Rpb24gbG9uZ2VzdFBvc2l0aXZlSW5jcmVhc2luZ1N1YnNlcXVlbmNlKG5zLCBuZXdTdGFydCkge1xuICB2YXIgc2VxID0gW10sXG4gICAgICBpcyA9IFtdLFxuICAgICAgbCA9IC0xLFxuICAgICAgcHJlID0gbmV3IEFycmF5KG5zLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IG5ld1N0YXJ0LCBsZW4gPSBucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBuID0gbnNbaV07XG4gICAgaWYgKG4gPCAwKSBjb250aW51ZTtcbiAgICB2YXIgaiA9IGZpbmRHcmVhdGVzdEluZGV4TEVRKHNlcSwgbik7XG4gICAgaWYgKGogIT09IC0xKSBwcmVbaV0gPSBpc1tqXTtcblxuICAgIGlmIChqID09PSBsKSB7XG4gICAgICBsKys7XG4gICAgICBzZXFbbF0gPSBuO1xuICAgICAgaXNbbF0gPSBpO1xuICAgIH0gZWxzZSBpZiAobiA8IHNlcVtqICsgMV0pIHtcbiAgICAgIHNlcVtqICsgMV0gPSBuO1xuICAgICAgaXNbaiArIDFdID0gaTtcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSBpc1tsXTsgbCA+PSAwOyBpID0gcHJlW2ldLCBsLS0pIHtcbiAgICBzZXFbbF0gPSBpO1xuICB9XG5cbiAgcmV0dXJuIHNlcTtcbn1cblxuZnVuY3Rpb24gZmluZEdyZWF0ZXN0SW5kZXhMRVEoc2VxLCBuKSB7XG4gIC8vIGludmFyaWFudDogbG8gaXMgZ3VhcmFudGVlZCB0byBiZSBpbmRleCBvZiBhIHZhbHVlIDw9IG4sIGhpIHRvIGJlID5cbiAgLy8gdGhlcmVmb3JlLCB0aGV5IGFjdHVhbGx5IHN0YXJ0IG91dCBvZiByYW5nZTogKC0xLCBsYXN0ICsgMSlcbiAgdmFyIGxvID0gLTEsXG4gICAgICBoaSA9IHNlcS5sZW5ndGg7IC8vIGZhc3QgcGF0aCBmb3Igc2ltcGxlIGluY3JlYXNpbmcgc2VxdWVuY2VzXG5cbiAgaWYgKGhpID4gMCAmJiBzZXFbaGkgLSAxXSA8PSBuKSByZXR1cm4gaGkgLSAxO1xuXG4gIHdoaWxlIChoaSAtIGxvID4gMSkge1xuICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsbyArIGhpKSAvIDIpO1xuXG4gICAgaWYgKHNlcVttaWRdID4gbikge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsbztcbn1cblxuY29uc3QgVHlwZXMgPSB7XG4gIEFUVFJJQlVURTogJ2F0dHJpYnV0ZScsXG4gIFBST1BFUlRZOiAncHJvcGVydHknXG59O1xudmFyIEF0dHJpYnV0ZXMgPSB7XG4gIGhyZWY6IHtcbiAgICB0eXBlOiBUeXBlcy5BVFRSSUJVVEVcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICB0eXBlOiBUeXBlcy5QUk9QRVJUWSxcbiAgICBhbGlhczogJ3N0eWxlLmNzc1RleHQnXG4gIH0sXG4gIGZvcjoge1xuICAgIHR5cGU6IFR5cGVzLlBST1BFUlRZLFxuICAgIGFsaWFzOiAnaHRtbEZvcidcbiAgfSxcbiAgY2xhc3M6IHtcbiAgICB0eXBlOiBUeXBlcy5QUk9QRVJUWSxcbiAgICBhbGlhczogJ2NsYXNzTmFtZSdcbiAgfSxcbiAgLy8gUmVhY3QgY29tcGF0XG4gIHNwZWxsQ2hlY2s6IHtcbiAgICB0eXBlOiBUeXBlcy5QUk9QRVJUWSxcbiAgICBhbGlhczogJ3NwZWxsY2hlY2snXG4gIH0sXG4gIGFsbG93RnVsbFNjcmVlbjoge1xuICAgIHR5cGU6IFR5cGVzLlBST1BFUlRZLFxuICAgIGFsaWFzOiAnYWxsb3dGdWxsc2NyZWVuJ1xuICB9LFxuICBhdXRvQ2FwaXRhbGl6ZToge1xuICAgIHR5cGU6IFR5cGVzLlBST1BFUlRZLFxuICAgIGFsaWFzOiAnYXV0b2NhcGl0YWxpemUnXG4gIH0sXG4gIGF1dG9Gb2N1czoge1xuICAgIHR5cGU6IFR5cGVzLlBST1BFUlRZLFxuICAgIGFsaWFzOiAnYXV0b2ZvY3VzJ1xuICB9LFxuICBhdXRvUGxheToge1xuICAgIHR5cGU6IFR5cGVzLlBST1BFUlRZLFxuICAgIGFsaWFzOiAnYXV0b3BsYXknXG4gIH1cbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgYXJyYXkpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcblxuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgbm9ybWFsaXplZC5wdXNoKGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAoaXRlbSA9PSBudWxsIHx8IGl0ZW0gPT09IHRydWUgfHwgaXRlbSA9PT0gZmFsc2UpIDtlbHNlIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBub3JtYWxpemVJbmNvbWluZ0FycmF5KG5vcm1hbGl6ZWQsIGl0ZW0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBub3JtYWxpemVkLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWQucHVzaChpdGVtLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub3JtYWxpemVkO1xufVxuXG5mdW5jdGlvbiBjbGVhckFsbChwYXJlbnQsIGN1cnJlbnQsIG1hcmtlcikge1xuICBpZiAoIW1hcmtlcikgcmV0dXJuIHBhcmVudC50ZXh0Q29udGVudCA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudFtpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9ICcnKSBwYXJlbnQucmVtb3ZlQ2hpbGQobWFya2VyLnByZXZpb3VzU2libGluZyk7XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBtb2RlbChlbCkge1xuICBsZXQgbSA9IGVsLm1vZGVsLFxuICAgICAgYSA9IGVsLmFjdGlvbixcbiAgICAgIHI7XG4gIGlmICghbSAmJiBlbC5wYXJlbnROb2RlKSByID0gbW9kZWwoZWwucGFyZW50Tm9kZSk7XG4gIHJldHVybiBbbSB8fCByICYmIHJbMF0sIGEgfHwgciAmJiByWzFdXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUnVudGltZShvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICB3cmFwLFxuICAgIGNsZWFudXAsXG4gICAgcm9vdFxuICB9ID0gb3B0aW9ucztcblxuICBmdW5jdGlvbiBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgdmFsdWUsIGN1cnJlbnQsIG1hcmtlcikge1xuICAgIGlmICh2YWx1ZSA9PT0gY3VycmVudCkgcmV0dXJuIGN1cnJlbnQ7XG4gICAgcGFyZW50ID0gbWFya2VyICYmIG1hcmtlci5wYXJlbnROb2RlIHx8IHBhcmVudDtcbiAgICBjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuXG4gICAgaWYgKHQgPT09ICdzdHJpbmcnIHx8IHQgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAodCA9PT0gJ251bWJlcicpIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gJycgJiYgdHlwZW9mIGN1cnJlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY3VycmVudCA9IG1hcmtlci5wcmV2aW91c1NpYmxpbmcuZGF0YSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gJycgJiYgY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKG5vZGUsIG1hcmtlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIG1hcmtlcik7XG5cbiAgICAgICAgICBjdXJyZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSAnJyAmJiB0eXBlb2YgY3VycmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50LmZpcnN0Q2hpbGQuZGF0YSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgY3VycmVudCA9IHBhcmVudC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gJycgfHwgdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBjdXJyZW50ID0gY2xlYXJBbGwocGFyZW50LCBjdXJyZW50LCBtYXJrZXIpO1xuICAgIH0gZWxzZSBpZiAodCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGN1cnJlbnQgPSBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgdmFsdWUoKSwgY3VycmVudCwgbWFya2VyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHZhbHVlLCBtYXJrZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZCh2YWx1ZSwgY3VycmVudFswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xlYXJBbGwocGFyZW50LCBjdXJyZW50LCBtYXJrZXIpO1xuICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudCA9PSBudWxsIHx8IGN1cnJlbnQgPT09ICcnKSB7XG4gICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodmFsdWUsIG1hcmtlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHZhbHVlLCBtYXJrZXIgJiYgbWFya2VyLnByZXZpb3VzU2libGluZyB8fCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBsZXQgYXJyYXkgPSBub3JtYWxpemVJbmNvbWluZ0FycmF5KFtdLCB2YWx1ZSk7XG4gICAgICBjbGVhckFsbChwYXJlbnQsIGN1cnJlbnQsIG1hcmtlcik7XG5cbiAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2YgTm9kZSkpIG5vZGUgPSBhcnJheVtpXSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpO1xuICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gYXJyYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRlbnQgbXVzdCBiZSBOb2RlLCBzdHJpbmdhYmxlLCBvciBhcnJheSBvZiBzYW1lXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgIGluc2VydChwYXJlbnQsIGFjY2Vzc29yLCBpbml0LCBtYXJrZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgYWNjZXNzb3IgIT09ICdmdW5jdGlvbicpIHJldHVybiBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgYWNjZXNzb3IsIGluaXQsIG1hcmtlcik7XG4gICAgICB3cmFwKChjdXJyZW50ID0gaW5pdCkgPT4gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIGFjY2Vzc29yKCksIGN1cnJlbnQsIG1hcmtlcikpO1xuICAgIH0sXG5cbiAgICBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZSA9PiB7XG4gICAgICAgIGlmIChoYW5kbGVyLmxlbmd0aCA8IDIpIHJldHVybiBoYW5kbGVyKGUpO1xuICAgICAgICBjb25zdCBhID0gbW9kZWwoZS50YXJnZXQpO1xuICAgICAgICBoYW5kbGVyKGUsIGFbMF0sIGFbMV0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNwcmVhZChub2RlLCBhY2Nlc3Nvcikge1xuICAgICAgd3JhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gYWNjZXNzb3IoKTtcbiAgICAgICAgbGV0IGluZm87XG5cbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcblxuICAgICAgICAgIGlmIChwcm9wID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdjbGFzc0xpc3QnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBpbiB2YWx1ZSkgbm9kZS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgdmFsdWVbY2xhc3NOYW1lXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbmZvID0gQXR0cmlidXRlc1twcm9wXSkge1xuICAgICAgICAgICAgaWYgKGluZm8udHlwZSA9PT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIG5vZGVbaW5mby5hbGlhc10gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Ugbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZmxvdyhwYXJlbnQsIHR5cGUsIGFjY2Vzc29yLCBleHByLCBhZnRlclJlbmRlciwgbWFya2VyKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2VhY2gnKSB7XG4gICAgICAgIGxldCBzdGFydE5vZGU7XG4gICAgICAgIGlmIChtYXJrZXIpIHN0YXJ0Tm9kZSA9IG1hcmtlci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29uY2lsZShwYXJlbnQsIGFjY2Vzc29yLCBleHByLCBhZnRlclJlbmRlciwgb3B0aW9ucywgc3RhcnROb2RlLCBtYXJrZXIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnd2hlbicpIHtcbiAgICAgICAgbGV0IGN1cnJlbnQsIGRpc3Bvc2FibGU7XG4gICAgICAgIGNsZWFudXAoZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICAgICBkaXNwb3NhYmxlICYmIGRpc3Bvc2FibGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdyYXAoY2FjaGVkID0+IHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFjY2Vzc29yKCk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgICAgZGlzcG9zYWJsZSAmJiBkaXNwb3NhYmxlKCk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNsZWFyQWxsKHBhcmVudCwgY2FjaGVkLCBtYXJrZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvb3QoZGlzcG9zZXIgPT4ge1xuICAgICAgICAgICAgZGlzcG9zYWJsZSA9IGRpc3Bvc2VyO1xuICAgICAgICAgICAgY3VycmVudCA9IGluc2VydEV4cHJlc3Npb24ocGFyZW50LCBleHByKHZhbHVlKSwgY3VycmVudCwgbWFya2VyKTtcbiAgICAgICAgICAgIGFmdGVyUmVuZGVyICYmIGFmdGVyUmVuZGVyKGN1cnJlbnQsIG1hcmtlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJ1bnRpbWUgfTsiLCJpbXBvcnQgeyBjcmVhdGVSdW50aW1lIH0gZnJvbSAnYmFiZWwtcGx1Z2luLWpzeC1kb20tZXhwcmVzc2lvbnMnO1xuaW1wb3J0IFMgZnJvbSAncy1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhbmRsZXIoY2xhc3NOYW1lKSB7XG4gIHJldHVybiAoZSwgcykgPT4gZS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgcyk7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dEaWZmKGEsIGIpIHtcbiAgbGV0IHNhID0gbmV3IFNldChhKSxcbiAgICAgIHNiID0gbmV3IFNldChiKTtcbiAgcmV0dXJuIFthLmZpbHRlcihpID0+ICFzYi5oYXMoaSkpLCBiLmZpbHRlcihpID0+ICFzYS5oYXMoaSkpXTtcbn1cblxuY29uc3QgciA9IGNyZWF0ZVJ1bnRpbWUoe1xuICB3cmFwOiBTLm1ha2VDb21wdXRhdGlvbk5vZGUsXG4gIHJvb3Q6IFMucm9vdCxcbiAgY2xlYW51cDogUy5jbGVhbnVwLFxuICBzYW1wbGU6IFMuc2FtcGxlXG59KTtcblxuZnVuY3Rpb24gc2VsZWN0V2hlbihzaWduYWwsIGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykgaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoaGFuZGxlcik7XG4gIGxldCBzdGFydCwgZW5kO1xuICBTLm1ha2VDb21wdXRhdGlvbk5vZGUoZWxlbWVudCA9PiB7XG4gICAgY29uc3QgbW9kZWwgPSBzaWduYWwoKTtcbiAgICBpZiAoZWxlbWVudCkgaGFuZGxlcihlbGVtZW50LCBmYWxzZSk7XG4gICAgbGV0IG1hcmtlciA9IHN0YXJ0O1xuXG4gICAgd2hpbGUgKG1hcmtlciAmJiBtYXJrZXIgIT09IGVuZCkge1xuICAgICAgaWYgKG1hcmtlci5tb2RlbCA9PT0gbW9kZWwpIHtcbiAgICAgICAgaGFuZGxlcihtYXJrZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgICAgfVxuXG4gICAgICBtYXJrZXIgPSBtYXJrZXIubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIChzLCBlKSA9PiAoc3RhcnQgPSBzLCBlbmQgPSBlKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0RWFjaChzaWduYWwsIGhhbmRsZXIpIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykgaGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoaGFuZGxlcik7XG4gIGxldCBzdGFydCwgZW5kO1xuICBTLm1ha2VDb21wdXRhdGlvbk5vZGUoZWxlbWVudHMgPT4ge1xuICAgIGNvbnN0IG1vZGVscyA9IHNpZ25hbCgpLFxuICAgICAgICAgIG5ld0VsZW1lbnRzID0gW107XG4gICAgbGV0IG1hcmtlciA9IHN0YXJ0O1xuXG4gICAgd2hpbGUgKG1hcmtlciAmJiBtYXJrZXIgIT09IGVuZCkge1xuICAgICAgaWYgKG1vZGVscy5pbmRleE9mKG1hcmtlci5tb2RlbCkgPiAtMSkgbmV3RWxlbWVudHMucHVzaChtYXJrZXIpO1xuICAgICAgbWFya2VyID0gbWFya2VyLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIGNvbnN0IFthZGRpdGlvbnMsIHJlbW92YWxzXSA9IHNoYWxsb3dEaWZmKG5ld0VsZW1lbnRzLCBlbGVtZW50cyk7XG4gICAgYWRkaXRpb25zLmZvckVhY2goZWwgPT4gaGFuZGxlcihlbCwgdHJ1ZSkpO1xuICAgIHJlbW92YWxzLmZvckVhY2goZWwgPT4gaGFuZGxlcihlbCwgZmFsc2UpKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH0pO1xuICByZXR1cm4gKHMsIGUpID0+IChzdGFydCA9IHMsIGVuZCA9IGUpO1xufVxuXG5leHBvcnQgeyByLCBzZWxlY3RXaGVuLCBzZWxlY3RFYWNoIH07IiwiY29uc3QgX3RtcGwkNyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcblxuX3RtcGwkNy5pbm5lckhUTUwgPSBcIjxidXR0b24gY2xhc3M9J2NsZWFyLWNvbXBsZXRlZCc+Q2xlYXIgY29tcGxldGVkPC9idXR0b24+XCI7XG5cbmNvbnN0IF90bXBsJDYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5cbl90bXBsJDYuaW5uZXJIVE1MID0gXCI8Zm9vdGVyIGNsYXNzPSdmb290ZXInPjxzcGFuIGNsYXNzPSd0b2RvLWNvdW50Jz48c3Ryb25nPjwvc3Ryb25nPiBsZWZ0XFxuICAgIDwvc3Bhbj48dWwgY2xhc3M9J2ZpbHRlcnMnPjxsaT48YSBocmVmPScjLyc+QWxsPC9hPjwvbGk+PHNwYW4+PC9zcGFuPjxsaT48YSBocmVmPScjL2FjdGl2ZSc+QWN0aXZlPC9hPjwvbGk+PHNwYW4+PC9zcGFuPjxsaT48YSBocmVmPScjL2NvbXBsZXRlZCc+Q29tcGxldGVkPC9hPjwvbGk+PC91bD48L2Zvb3Rlcj5cIjtcblxuY29uc3QgX3RtcGwkNSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcblxuX3RtcGwkNS5pbm5lckhUTUwgPSBcIjxpbnB1dCBjbGFzcz0nZWRpdCcvPlwiO1xuXG5jb25zdCBfdG1wbCQ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuXG5fdG1wbCQ0LmlubmVySFRNTCA9IFwiPGxpIGNsYXNzPSd0b2RvJz48ZGl2IGNsYXNzPSd2aWV3Jz48aW5wdXQgY2xhc3M9J3RvZ2dsZScgdHlwZT0nY2hlY2tib3gnLz48bGFiZWw+PC9sYWJlbD48YnV0dG9uIGNsYXNzPSdkZXN0cm95Jz48L2J1dHRvbj48L2Rpdj48L2xpPlwiO1xuXG5jb25zdCBfdG1wbCQzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuXG5fdG1wbCQzLmlubmVySFRNTCA9IFwiPHNlY3Rpb24gY2xhc3M9J21haW4nPjxpbnB1dCBpZD0ndG9nZ2xlLWFsbCcgY2xhc3M9J3RvZ2dsZS1hbGwnIHR5cGU9J2NoZWNrYm94Jy8+PGxhYmVsIGZvcj0ndG9nZ2xlLWFsbCc+PC9sYWJlbD48dWwgY2xhc3M9J3RvZG8tbGlzdCc+PC91bD48L3NlY3Rpb24+XCI7XG5cbmNvbnN0IF90bXBsJDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG5cbl90bXBsJDIuaW5uZXJIVE1MID0gXCI8aGVhZGVyIGNsYXNzPSdoZWFkZXInPjxoMT50b2RvczwvaDE+PGlucHV0IGNsYXNzPSduZXctdG9kbycgcGxhY2Vob2xkZXI9J1doYXQgbmVlZHMgdG8gYmUgZG9uZT8nLz48L2hlYWRlcj5cIjtcblxuY29uc3QgX3RtcGwkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuXG5fdG1wbCQuaW5uZXJIVE1MID0gXCI8c2VjdGlvbiBjbGFzcz0ndG9kb2FwcCc+PC9zZWN0aW9uPlwiO1xuaW1wb3J0IHsgZWFjaCwgd2hlbiB9IGZyb20gJ3NvbGlkLWpzJztcbmltcG9ydCB7IHIgfSBmcm9tICdzb2xpZC1qcy9kb20nO1xuY29uc3QgRVNDQVBFX0tFWSA9IDI3LFxuICAgICAgRU5URVJfS0VZID0gMTM7XG5cbmNvbnN0IFRvZG9BcHAgPSBwcm9wcyA9PiBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IF9lbCQgPSBfdG1wbCQuY29udGVudC5maXJzdENoaWxkLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgX2VsJDIgPSBfZWwkLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSwgX2VsJC5maXJzdENoaWxkKSxcbiAgICAgICAgX2VsJDMgPSBfZWwkLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSwgX2VsJDIubmV4dFNpYmxpbmcpLFxuICAgICAgICBfZWwkNCA9IF9lbCQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpLCBfZWwkMy5uZXh0U2libGluZyk7XG5cbiAgci5pbnNlcnQoX2VsJCwgVG9kb0hlYWRlcihwcm9wcyksIG51bGwsIF9lbCQyKTtcbiAgci5mbG93KF9lbCQsIFwid2hlblwiLCAoKSA9PiBwcm9wcy5zdGF0ZS50b2Rvcy5sZW5ndGggPiAwLCAoKSA9PiBUb2RvTGlzdChwcm9wcyksIG51bGwsIF9lbCQzKTtcbiAgci5mbG93KF9lbCQsIFwid2hlblwiLCAoKSA9PiBwcm9wcy5zdGF0ZS50b2Rvcy5sZW5ndGggPiAwLCAoKSA9PiBUb2RvRm9vdGVyKHByb3BzKSwgbnVsbCwgX2VsJDQpO1xuICByZXR1cm4gX2VsJDtcbn0oKTtcblxuY29uc3QgVG9kb0hlYWRlciA9ICh7XG4gIGFkZFRvZG9cbn0pID0+IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgX2VsJDUgPSBfdG1wbCQyLmNvbnRlbnQuZmlyc3RDaGlsZC5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgIF9lbCQ2ID0gX2VsJDUuZmlyc3RDaGlsZCxcbiAgICAgICAgX2VsJDcgPSBfZWwkNi5uZXh0U2libGluZztcblxuICByLmFkZEV2ZW50TGlzdGVuZXIoX2VsJDcsIFwia2V5dXBcIiwgKHtcbiAgICB0YXJnZXQsXG4gICAga2V5Q29kZVxuICB9KSA9PiB7XG4gICAgbGV0IHRpdGxlO1xuICAgIGlmICghKGtleUNvZGUgPT09IEVOVEVSX0tFWSAmJiAodGl0bGUgPSB0YXJnZXQudmFsdWUudHJpbSgpKSkpIHJldHVybjtcbiAgICBhZGRUb2RvKHtcbiAgICAgIHRpdGxlXG4gICAgfSk7XG4gICAgdGFyZ2V0LnZhbHVlID0gJyc7XG4gIH0pO1xuICByZXR1cm4gX2VsJDU7XG59KCk7XG5cbmNvbnN0IFRvZG9MaXN0ID0gcHJvcHMgPT4ge1xuICBjb25zdCB7XG4gICAgc3RhdGUsXG4gICAgdG9nZ2xlQWxsXG4gIH0gPSBwcm9wcztcblxuICBmdW5jdGlvbiBmaWx0ZXJMaXN0KHRvZG9zKSB7XG4gICAgaWYgKHN0YXRlLnNob3dNb2RlID09PSAnYWN0aXZlJykgcmV0dXJuIHRvZG9zLmZpbHRlcih0b2RvID0+ICF0b2RvLmNvbXBsZXRlZCk7ZWxzZSBpZiAoc3RhdGUuc2hvd01vZGUgPT09ICdjb21wbGV0ZWQnKSByZXR1cm4gdG9kb3MuZmlsdGVyKHRvZG8gPT4gdG9kby5jb21wbGV0ZWQpO2Vsc2UgcmV0dXJuIHRvZG9zO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfZWwkOCA9IF90bXBsJDMuY29udGVudC5maXJzdENoaWxkLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgICBfZWwkOSA9IF9lbCQ4LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgX2VsJDEwID0gX2VsJDkubmV4dFNpYmxpbmcsXG4gICAgICAgICAgX2VsJDExID0gX2VsJDEwLm5leHRTaWJsaW5nO1xuXG4gICAgci5hZGRFdmVudExpc3RlbmVyKF9lbCQ5LCBcImNoYW5nZVwiLCAoe1xuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH1cbiAgICB9KSA9PiB0b2dnbGVBbGwoY2hlY2tlZCkpO1xuICAgIHIud3JhcCgoKSA9PiBfZWwkOS5jaGVja2VkID0gIXN0YXRlLnJlbWFpbmluZ0NvdW50KTtcbiAgICByLmZsb3coX2VsJDExLCBcImVhY2hcIiwgKCkgPT4gZmlsdGVyTGlzdChzdGF0ZS50b2RvcyksIHRvZG8gPT4gVG9kb0l0ZW0oT2JqZWN0LmFzc2lnbihwcm9wcywge1xuICAgICAgdG9kbzogdG9kb1xuICAgIH0pKSwgbnVsbCk7XG4gICAgcmV0dXJuIF9lbCQ4O1xuICB9KCk7XG59O1xuXG5jb25zdCBUb2RvSXRlbSA9ICh7XG4gIHN0YXRlLFxuICBlZGl0VG9kbyxcbiAgcmVtb3ZlVG9kbyxcbiAgc2V0Q3VycmVudCxcbiAgdG9kb1xufSkgPT4ge1xuICBmdW5jdGlvbiBvblNhdmUoe1xuICAgIHRhcmdldDoge1xuICAgICAgdmFsdWVcbiAgICB9XG4gIH0pIHtcbiAgICBsZXQgdGl0bGU7XG4gICAgaWYgKCEoc3RhdGUuZWRpdHRpbmdUb2RvSWQgPT09IHRvZG8uaWQgJiYgKHRpdGxlID0gdmFsdWUudHJpbSgpKSkpIHJldHVybjtcbiAgICBlZGl0VG9kbyh7XG4gICAgICBpZDogdG9kby5pZCxcbiAgICAgIHRpdGxlXG4gICAgfSk7XG4gICAgc2V0Q3VycmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfZWwkMTIgPSBfdG1wbCQ0LmNvbnRlbnQuZmlyc3RDaGlsZC5jbG9uZU5vZGUodHJ1ZSksXG4gICAgICAgICAgX2VsJDEzID0gX2VsJDEyLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgX2VsJDE0ID0gX2VsJDEzLmZpcnN0Q2hpbGQsXG4gICAgICAgICAgX2VsJDE1ID0gX2VsJDE0Lm5leHRTaWJsaW5nLFxuICAgICAgICAgIF9lbCQxNiA9IF9lbCQxNS5uZXh0U2libGluZyxcbiAgICAgICAgICBfZWwkMTcgPSBfZWwkMTIuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpLCBfZWwkMTMubmV4dFNpYmxpbmcpO1xuXG4gICAgci53cmFwKCgpID0+IHtcbiAgICAgIGxldCBjbGFzc05hbWVzID0ge1xuICAgICAgICBjb21wbGV0ZWQ6IHRvZG8uY29tcGxldGVkLFxuICAgICAgICBlZGl0aW5nOiB0b2RvLmlkID09PSBzdGF0ZS5lZGl0dGluZ1RvZG9JZFxuICAgICAgfTtcbiAgICAgIGxldCBjbGFzc0tleXMgPSBPYmplY3Qua2V5cyhjbGFzc05hbWVzKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0tleXMubGVuZ3RoOyBpKyspIF9lbCQxMi5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzS2V5c1tpXSwgY2xhc3NOYW1lc1tjbGFzc0tleXNbaV1dKTtcbiAgICB9KTtcbiAgICByLmFkZEV2ZW50TGlzdGVuZXIoX2VsJDE0LCBcImNoYW5nZVwiLCAoe1xuICAgICAgdGFyZ2V0OiB7XG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH1cbiAgICB9KSA9PiBlZGl0VG9kbyh7XG4gICAgICBpZDogdG9kby5pZCxcbiAgICAgIGNvbXBsZXRlZDogY2hlY2tlZFxuICAgIH0pKTtcbiAgICByLndyYXAoKCkgPT4gX2VsJDE0LmNoZWNrZWQgPSB0b2RvLmNvbXBsZXRlZCk7XG4gICAgci5hZGRFdmVudExpc3RlbmVyKF9lbCQxNSwgXCJkYmxjbGlja1wiLCAoKSA9PiBzZXRDdXJyZW50KHRvZG8uaWQpKTtcbiAgICByLmluc2VydChfZWwkMTUsICgpID0+IHRvZG8udGl0bGUpO1xuICAgIHIuYWRkRXZlbnRMaXN0ZW5lcihfZWwkMTYsIFwiY2xpY2tcIiwgKCkgPT4gcmVtb3ZlVG9kbyh0b2RvLmlkKSk7XG4gICAgci5pbnNlcnQoX2VsJDEyLCAoKSA9PiB0b2RvLmlkID09PSBzdGF0ZS5lZGl0dGluZ1RvZG9JZCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBfZWwkMTggPSBfdG1wbCQ1LmNvbnRlbnQuZmlyc3RDaGlsZC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICAgIHIuYWRkRXZlbnRMaXN0ZW5lcihfZWwkMTgsIFwia2V5dXBcIiwgZSA9PiB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IEVOVEVSX0tFWSkgb25TYXZlKGUpO2Vsc2UgaWYgKGUua2V5Q29kZSA9PT0gRVNDQVBFX0tFWSkgc2V0Q3VycmVudCgpO1xuICAgICAgfSk7XG4gICAgICByLmFkZEV2ZW50TGlzdGVuZXIoX2VsJDE4LCBcImJsdXJcIiwgb25TYXZlKTtcbiAgICAgIF9lbCQxOC52YWx1ZSA9IHRvZG8udGl0bGU7XG4gICAgICByZXR1cm4gX2VsJDE4O1xuICAgIH0oKSwgbnVsbCwgX2VsJDE3KTtcbiAgICByZXR1cm4gX2VsJDEyO1xuICB9KCk7XG59O1xuXG5jb25zdCBUb2RvRm9vdGVyID0gKHtcbiAgc3RhdGUsXG4gIGNsZWFyQ29tcGxldGVkXG59KSA9PiBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IF9lbCQxOSA9IF90bXBsJDYuY29udGVudC5maXJzdENoaWxkLmNsb25lTm9kZSh0cnVlKSxcbiAgICAgICAgX2VsJDIwID0gX2VsJDE5LmZpcnN0Q2hpbGQsXG4gICAgICAgIF9lbCQyMSA9IF9lbCQyMC5maXJzdENoaWxkLFxuICAgICAgICBfZWwkMjIgPSBfZWwkMjAuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpLCBfZWwkMjEubmV4dFNpYmxpbmcpLFxuICAgICAgICBfZWwkMjMgPSBfZWwkMjAubmV4dFNpYmxpbmcsXG4gICAgICAgIF9lbCQyNCA9IF9lbCQyMy5maXJzdENoaWxkLFxuICAgICAgICBfZWwkMjUgPSBfZWwkMjQuZmlyc3RDaGlsZCxcbiAgICAgICAgX2VsJDI2ID0gX2VsJDI0Lm5leHRTaWJsaW5nLFxuICAgICAgICBfZWwkMjcgPSBfZWwkMjYubmV4dFNpYmxpbmcsXG4gICAgICAgIF9lbCQyOCA9IF9lbCQyNy5maXJzdENoaWxkLFxuICAgICAgICBfZWwkMjkgPSBfZWwkMjcubmV4dFNpYmxpbmcsXG4gICAgICAgIF9lbCQzMCA9IF9lbCQyOS5uZXh0U2libGluZyxcbiAgICAgICAgX2VsJDMxID0gX2VsJDMwLmZpcnN0Q2hpbGQsXG4gICAgICAgIF9lbCQzMiA9IF9lbCQxOS5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIiksIF9lbCQyMy5uZXh0U2libGluZyk7XG5cbiAgci5pbnNlcnQoX2VsJDIxLCAoKSA9PiBzdGF0ZS5yZW1haW5pbmdDb3VudCk7XG4gIHIuaW5zZXJ0KF9lbCQyMCwgKCkgPT4gc3RhdGUucmVtYWluaW5nQ291bnQgPT09IDEgPyAnIGl0ZW0nIDogJyBpdGVtcycsIG51bGwsIF9lbCQyMik7XG4gIHIud3JhcCgoKSA9PiB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSB7XG4gICAgICBzZWxlY3RlZDogc3RhdGUuc2hvd01vZGUgPT09ICdhbGwnXG4gICAgfTtcbiAgICBsZXQgY2xhc3NLZXlzID0gT2JqZWN0LmtleXMoY2xhc3NOYW1lcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzS2V5cy5sZW5ndGg7IGkrKykgX2VsJDI1LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NLZXlzW2ldLCBjbGFzc05hbWVzW2NsYXNzS2V5c1tpXV0pO1xuICB9KTtcbiAgci53cmFwKCgpID0+IHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IHtcbiAgICAgIHNlbGVjdGVkOiBzdGF0ZS5zaG93TW9kZSA9PT0gJ2FjdGl2ZSdcbiAgICB9O1xuICAgIGxldCBjbGFzc0tleXMgPSBPYmplY3Qua2V5cyhjbGFzc05hbWVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3NLZXlzLmxlbmd0aDsgaSsrKSBfZWwkMjguY2xhc3NMaXN0LnRvZ2dsZShjbGFzc0tleXNbaV0sIGNsYXNzTmFtZXNbY2xhc3NLZXlzW2ldXSk7XG4gIH0pO1xuICByLndyYXAoKCkgPT4ge1xuICAgIGxldCBjbGFzc05hbWVzID0ge1xuICAgICAgc2VsZWN0ZWQ6IHN0YXRlLnNob3dNb2RlID09PSAnY29tcGxldGVkJ1xuICAgIH07XG4gICAgbGV0IGNsYXNzS2V5cyA9IE9iamVjdC5rZXlzKGNsYXNzTmFtZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc0tleXMubGVuZ3RoOyBpKyspIF9lbCQzMS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzS2V5c1tpXSwgY2xhc3NOYW1lc1tjbGFzc0tleXNbaV1dKTtcbiAgfSk7XG4gIHIuZmxvdyhfZWwkMTksIFwid2hlblwiLCAoKSA9PiBzdGF0ZS5jb21wbGV0ZWRDb3VudCA+IDAsICgpID0+IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBfZWwkMzMgPSBfdG1wbCQ3LmNvbnRlbnQuZmlyc3RDaGlsZC5jbG9uZU5vZGUodHJ1ZSk7XG5cbiAgICByLmFkZEV2ZW50TGlzdGVuZXIoX2VsJDMzLCBcImNsaWNrXCIsIGNsZWFyQ29tcGxldGVkKTtcbiAgICByZXR1cm4gX2VsJDMzO1xuICB9KCksIG51bGwsIF9lbCQzMik7XG4gIHJldHVybiBfZWwkMTk7XG59KCk7XG5cbmV4cG9ydCBkZWZhdWx0IFRvZG9BcHA7IiwiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNsZWFudXAsIHVzZUVmZmVjdCB9IGZyb20gJ3NvbGlkLWpzJztcbmNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZID0gJ3RvZG9zLXNvbGlkJztcblxuZnVuY3Rpb24gdXNlTG9jYWwoXykge1xuICAvLyBsb2FkIHN0b3JlZCB0b2RvcyBvbiBpbml0XG4gIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKExPQ0FMX1NUT1JBR0VfS0VZKSxcbiAgICAgICAgW3N0YXRlLCBzZXRTdGF0ZV0gPSBfO1xuICBpZiAoc3RvcmVkKSBzZXRTdGF0ZShKU09OLnBhcnNlKHN0b3JlZCkpOyAvLyBKU09OLnN0cmluZ2lmeSBjcmVhdGVzIGRlcHMgb24gZXZlcnkgaXRlcmFibGUgZmllbGRcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKExPQ0FMX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9KTtcbiAgcmV0dXJuIF87XG59XG5cbmV4cG9ydCBkZWZhdWx0ICgoKSA9PiB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlTG9jYWwodXNlU3RhdGUoe1xuICAgIGNvdW50ZXI6IDAsXG4gICAgZWRpdHRpbmdUb2RvSWQ6IG51bGwsXG4gICAgdG9kb3M6IFtdXG4gIH0pKSxcbiAgICAgICAgbG9jYXRpb25IYW5kbGVyID0gKCkgPT4gc2V0U3RhdGUoJ3Nob3dNb2RlJywgbG9jYXRpb24uaGFzaC5zbGljZSgyKSB8fCAnYWxsJyk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjb21wbGV0ZWRDb3VudCA9IHN0YXRlLnRvZG9zLmZpbHRlcih0b2RvID0+IHRvZG8uY29tcGxldGVkKS5sZW5ndGg7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgY29tcGxldGVkQ291bnQsXG4gICAgICByZW1haW5pbmdDb3VudDogc3RhdGUudG9kb3MubGVuZ3RoIC0gY29tcGxldGVkQ291bnRcbiAgICB9KTtcbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgbG9jYXRpb25IYW5kbGVyKTtcbiAgdXNlQ2xlYW51cCgoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIGxvY2F0aW9uSGFuZGxlcikpO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIGFkZFRvZG86ICh7XG4gICAgICB0aXRsZVxuICAgIH0pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gc3RhdGUuY291bnRlciArIDE7XG4gICAgICBzZXRTdGF0ZShbJ3RvZG9zJywgdCA9PiBbe1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbXBsZXRlZDogZmFsc2VcbiAgICAgIH0sIC4uLnRdXSwgWydjb3VudGVyJywgaWRdKTtcbiAgICB9LFxuICAgIHJlbW92ZVRvZG86IHRvZG9JZCA9PiBzZXRTdGF0ZSgndG9kb3MnLCB0ID0+IHQuZmlsdGVyKGl0ZW0gPT4gaXRlbS5pZCAhPT0gdG9kb0lkKSksXG4gICAgZWRpdFRvZG86IHRvZG8gPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBzdGF0ZS50b2Rvcy5maW5kSW5kZXgoaXRlbSA9PiBpdGVtLmlkID09PSB0b2RvLmlkKTtcbiAgICAgIHNldFN0YXRlKCd0b2RvcycsIGluZGV4LCB0b2RvKTtcbiAgICB9LFxuICAgIGNsZWFyQ29tcGxldGVkOiAoKSA9PiBzZXRTdGF0ZSgndG9kb3MnLCB0ID0+IHQuZmlsdGVyKHRvZG8gPT4gIXRvZG8uY29tcGxldGVkKSksXG4gICAgdG9nZ2xlQWxsOiBjb21wbGV0ZWQgPT4gc2V0U3RhdGUoJ3RvZG9zJywgdG9kbyA9PiB0b2RvLmNvbXBsZXRlZCAhPT0gY29tcGxldGVkLCB7XG4gICAgICBjb21wbGV0ZWRcbiAgICB9KSxcbiAgICBzZXRDdXJyZW50OiB0b2RvSWQgPT4gc2V0U3RhdGUoJ2VkaXR0aW5nVG9kb0lkJywgdG9kb0lkKVxuICB9O1xufSk7IiwiaW1wb3J0IHsgcm9vdCB9IGZyb20gJ3NvbGlkLWpzJztcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xuaW1wb3J0IG1hcFRvUHJvcHMgZnJvbSAnLi9tYXBUb1Byb3BzJztcbnJvb3QoKCkgPT4gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChBcHAobWFwVG9Qcm9wcygpKSkpOyJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2b0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")}]);